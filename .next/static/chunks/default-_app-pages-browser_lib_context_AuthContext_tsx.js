"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["default-_app-pages-browser_lib_context_AuthContext_tsx"],{

/***/ "(app-pages-browser)/./lib/context/AuthContext.tsx":
/*!*************************************!*\
  !*** ./lib/context/AuthContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuthContext: function() { return /* binding */ useAuthContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_useAuth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks/useAuth */ \"(app-pages-browser)/./lib/hooks/useAuth.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuthContext auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const auth = (0,_hooks_useAuth__WEBPACK_IMPORTED_MODULE_2__.useAuth)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: auth,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/jinayang/repos/NESA/lib/context/AuthContext.tsx\",\n        lineNumber: 29,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"YuJWYXaKIY31b1y7U6yy3IXSxQA=\", false, function() {\n    return [\n        _hooks_useAuth__WEBPACK_IMPORTED_MODULE_2__.useAuth\n    ];\n});\n_c = AuthProvider;\nconst useAuthContext = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuthContext must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuthContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jb250ZXh0L0F1dGhDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUV5RjtBQUM5QztBQW1CM0MsTUFBTUksNEJBQWNILG9EQUFhQSxDQUE4Qkk7QUFFeEQsTUFBTUMsZUFBa0Q7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQzFFLE1BQU1DLE9BQU9MLHVEQUFPQTtJQUVwQixxQkFDRSw4REFBQ0MsWUFBWUssUUFBUTtRQUFDQyxPQUFPRjtrQkFDMUJEOzs7Ozs7QUFHUCxFQUFFO0dBUldEOztRQUNFSCxtREFBT0E7OztLQURURztBQVVOLE1BQU1LLGlCQUFpQjs7SUFDNUIsTUFBTUMsVUFBVVYsaURBQVVBLENBQUNFO0lBQzNCLElBQUlRLFlBQVlQLFdBQVc7UUFDekIsTUFBTSxJQUFJUSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0lBTldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jb250ZXh0L0F1dGhDb250ZXh0LnRzeD9lZmZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJy4uL2hvb2tzL3VzZUF1dGgnO1xuXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgdXNlcjogYW55O1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIHVzZXJSb2xlOiBzdHJpbmcgfCBudWxsO1xuICBhY2NvdW50VHlwZTogc3RyaW5nIHwgbnVsbDtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgc2lnbkluOiAoY3JlZGVudGlhbHM6IHsgZW1haWw6IHN0cmluZzsgcGFzc3dvcmQ6IHN0cmluZyB9KSA9PiBQcm9taXNlPGFueT47XG4gIHZlcmlmeUVtYWlsOiAoZW1haWw6IHN0cmluZywgb3RwOiBzdHJpbmcpID0+IFByb21pc2U8YW55PjtcbiAgcmVnaXN0ZXI6ICh1c2VyRGF0YTogYW55KSA9PiBQcm9taXNlPGFueT47XG4gIGdldFVzZXJJZDogKCkgPT4gc3RyaW5nIHwgbnVsbDtcbiAgZ2V0VG9rZW46ICgpID0+IHN0cmluZyB8IG51bGw7XG4gIGxvZ291dDogKCkgPT4gdm9pZDtcbiAgdXBkYXRlVXNlcjogKHVzZXJEYXRhOiBhbnkpID0+IFByb21pc2U8YW55PjtcbiAgc2V0QXV0aGVudGljYXRpb25TdGF0ZTogKHVzZXJEYXRhOiBhbnksIHRva2VuOiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBjb25zdCBBdXRoUHJvdmlkZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgYXV0aCA9IHVzZUF1dGgoKTtcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17YXV0aH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VBdXRoQ29udGV4dCA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTsiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUF1dGgiLCJBdXRoQ29udGV4dCIsInVuZGVmaW5lZCIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwiYXV0aCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VBdXRoQ29udGV4dCIsImNvbnRleHQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/context/AuthContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/hooks/useAuth.ts":
/*!******************************!*\
  !*** ./lib/hooks/useAuth.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_authService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/authService */ \"(app-pages-browser)/./lib/services/authService.ts\");\n/* harmony import */ var _services_userService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/userService */ \"(app-pages-browser)/./lib/services/userService.ts\");\n\n\n\n// Cookie utility functions\nconst setCookie = (name, value, days)=>{\n    if (typeof document === \"undefined\") return;\n    const expires = new Date();\n    expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);\n    document.cookie = \"\".concat(name, \"=\").concat(value, \";expires=\").concat(expires.toUTCString(), \";path=/;SameSite=Lax\");\n};\nconst getCookie = (name)=>{\n    if (typeof document === \"undefined\") return null;\n    const nameEQ = name + \"=\";\n    const ca = document.cookie.split(\";\");\n    for(let i = 0; i < ca.length; i++){\n        let c = ca[i];\n        while(c.charAt(0) === \" \")c = c.substring(1, c.length);\n        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n};\nconst deleteCookie = (name)=>{\n    if (typeof document === \"undefined\") return;\n    document.cookie = \"\".concat(name, \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\");\n};\nconst useAuth = ()=>{\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Initialize auth state from cookies\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const token = getCookie(\"token\");\n        const userId = getCookie(\"userId\");\n        const emailVerified = getCookie(\"emailVerified\");\n        if (token && userId) {\n            setIsAuthenticated(true);\n            // Try to get user data from cookie or fetch from API\n            const userData = {\n                id: userId,\n                emailVerified: emailVerified === \"true\"\n            };\n            setUser(userData);\n        }\n    }, []);\n    // Utility functions\n    const getUserId = ()=>{\n        return getCookie(\"userId\") || \"\";\n    };\n    const getToken = ()=>{\n        return getCookie(\"token\");\n    };\n    const setAuthenticationState = (userData, token)=>{\n        setUser(userData);\n        setIsAuthenticated(true);\n        setCookie(\"token\", token, 7); // 7 days\n        setCookie(\"userId\", userData.id, 7);\n        setCookie(\"emailVerified\", userData.emailVerified ? \"true\" : \"false\", 7);\n    };\n    // Auth functions\n    const signIn = async (credentials)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.login)(credentials);\n            if (data.token) {\n                setAuthenticationState(data.user, data.token);\n            }\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Login failed\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const verifyEmail = async (email, otp)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.verifyOTP)({\n                email,\n                otp\n            });\n            if (data.token) {\n                setAuthenticationState(data.user, data.token);\n                // Clear temp cookies if they exist\n                deleteCookie(\"tempToken\");\n                deleteCookie(\"tempUserId\");\n            }\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"OTP verification failed\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const register = async (userData)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.signup)(userData);\n            if (data.token) {\n                setCookie(\"token\", data.token, 1); // Store token in cookies for 1 day\n                setCookie(\"userId\", data.user.id, 1); // Store userId in cookies for 1 day\n                setUser(data.user);\n            }\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Registration failed\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Enhanced signup flow with comprehensive data\n    const registerWithFlow = async (userData)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.signupFlow)(userData);\n            if (data.token) {\n                var _data_user;\n                // Don't set authenticated state yet - user needs email verification\n                setCookie(\"tempToken\", data.token, 1);\n                setCookie(\"tempUserId\", ((_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id) || \"\", 1);\n                setUser(data.user || null);\n                setIsAuthenticated(false); // Requires email verification\n            }\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Registration failed\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Send OTP for various purposes\n    const sendOTPCode = async function(email) {\n        let purpose = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"LOGIN\";\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.sendOTP)(email, purpose);\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to send OTP\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Get enhanced user profile\n    const getEnhancedProfile = async ()=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.getMe)();\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Failed to fetch profile\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const updateUser = async (userData)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const userId = getUserId(); // Use utility function\n            const data = await (0,_services_userService__WEBPACK_IMPORTED_MODULE_2__.updateUserById)(userId, userData);\n            setUser(data.user || data);\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Update failed\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const logout = ()=>{\n        setUser(null);\n        setIsAuthenticated(false);\n        setError(null);\n        // Clear all auth cookies\n        deleteCookie(\"token\");\n        deleteCookie(\"userId\");\n        deleteCookie(\"emailVerified\");\n        deleteCookie(\"tempToken\");\n        deleteCookie(\"tempUserId\");\n    };\n    const resetPassword = async (email)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const data = await (0,_services_authService__WEBPACK_IMPORTED_MODULE_1__.resetPassword)(email);\n            return data;\n        } catch (err) {\n            const errorMessage = err instanceof Error ? err.message : \"Password reset failed\";\n            setError(errorMessage);\n            throw err;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Computed properties\n    const userRole = (user === null || user === void 0 ? void 0 : user.role) || null;\n    const accountType = (user === null || user === void 0 ? void 0 : user.accountType) || null;\n    return {\n        user,\n        isAuthenticated,\n        userRole,\n        accountType,\n        error,\n        isLoading,\n        signIn,\n        verifyEmail,\n        register,\n        registerWithFlow,\n        sendOTPCode,\n        getEnhancedProfile,\n        updateUser,\n        getUserId,\n        getToken,\n        logout,\n        resetPassword,\n        setAuthenticationState\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy91c2VBdXRoLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQzBGO0FBQ2hFO0FBc0N0RSwyQkFBMkI7QUFDM0IsTUFBTVcsWUFBWSxDQUFDQyxNQUFjQyxPQUFlQztJQUM5QyxJQUFJLE9BQU9DLGFBQWEsYUFBYTtJQUVyQyxNQUFNQyxVQUFVLElBQUlDO0lBQ3BCRCxRQUFRRSxPQUFPLENBQUNGLFFBQVFHLE9BQU8sS0FBS0wsT0FBTyxLQUFLLEtBQUssS0FBSztJQUMxREMsU0FBU0ssTUFBTSxHQUFHLEdBQVdQLE9BQVJELE1BQUssS0FBb0JJLE9BQWpCSCxPQUFNLGFBQWlDLE9BQXRCRyxRQUFRSyxXQUFXLElBQUc7QUFDdEU7QUFFQSxNQUFNQyxZQUFZLENBQUNWO0lBQ2pCLElBQUksT0FBT0csYUFBYSxhQUFhLE9BQU87SUFFNUMsTUFBTVEsU0FBU1gsT0FBTztJQUN0QixNQUFNWSxLQUFLVCxTQUFTSyxNQUFNLENBQUNLLEtBQUssQ0FBQztJQUNqQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsR0FBR0csTUFBTSxFQUFFRCxJQUFLO1FBQ2xDLElBQUlFLElBQUlKLEVBQUUsQ0FBQ0UsRUFBRTtRQUNiLE1BQU9FLEVBQUVDLE1BQU0sQ0FBQyxPQUFPLElBQUtELElBQUlBLEVBQUVFLFNBQVMsQ0FBQyxHQUFHRixFQUFFRCxNQUFNO1FBQ3ZELElBQUlDLEVBQUVHLE9BQU8sQ0FBQ1IsWUFBWSxHQUFHLE9BQU9LLEVBQUVFLFNBQVMsQ0FBQ1AsT0FBT0ksTUFBTSxFQUFFQyxFQUFFRCxNQUFNO0lBQ3pFO0lBQ0EsT0FBTztBQUNUO0FBRUEsTUFBTUssZUFBZSxDQUFDcEI7SUFDcEIsSUFBSSxPQUFPRyxhQUFhLGFBQWE7SUFDckNBLFNBQVNLLE1BQU0sR0FBRyxHQUFRLE9BQUxSLE1BQUs7QUFDNUI7QUFFTyxNQUFNcUIsVUFBVTtJQUNyQixNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FB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O1FBQ0FFO1FBQ0FDO1FBQ0FsQjtRQUNBQztRQUNBa0I7UUFDQTdEO1FBQ0E0QztJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaG9va3MvdXNlQXV0aC50cz8zY2QwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGxvZ2luLCB2ZXJpZnlPVFAsIHNpZ251cCwgcmVzZXRQYXNzd29yZCBhcyByZXNldFBhc3N3b3JkU2VydmljZSwgc2lnbnVwRmxvdywgc2VuZE9UUCwgZ2V0TWUgfSBmcm9tIFwiLi4vc2VydmljZXMvYXV0aFNlcnZpY2VcIjtcbmltcG9ydCB7IGdldFVzZXJCeUlkLCB1cGRhdGVVc2VyQnlJZCB9IGZyb20gXCIuLi9zZXJ2aWNlcy91c2VyU2VydmljZVwiO1xuXG5pbnRlcmZhY2UgQ3JlZGVudGlhbHMge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT1RQRGF0YSB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG90cDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVXNlckRhdGEge1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICBub21pbmVlVHlwZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICByb2xlOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIHJlZ2lvbjogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBpbWFnZT86IHN0cmluZztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5pbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIGZ1bGxOYW1lPzogc3RyaW5nO1xuICBmaXJzdE5hbWU/OiBzdHJpbmc7XG4gIGxhc3ROYW1lPzogc3RyaW5nO1xuICByb2xlPzogc3RyaW5nO1xuICBhY2NvdW50VHlwZT86IHN0cmluZztcbiAgZW1haWxWZXJpZmllZD86IGJvb2xlYW47XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuLy8gQ29va2llIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBzZXRDb29raWUgPSAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBkYXlzOiBudW1iZXIpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIGNvbnN0IGV4cGlyZXMgPSBuZXcgRGF0ZSgpO1xuICBleHBpcmVzLnNldFRpbWUoZXhwaXJlcy5nZXRUaW1lKCkgKyBkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gIGRvY3VtZW50LmNvb2tpZSA9IGAke25hbWV9PSR7dmFsdWV9O2V4cGlyZXM9JHtleHBpcmVzLnRvVVRDU3RyaW5nKCl9O3BhdGg9LztTYW1lU2l0ZT1MYXhgO1xufTtcblxuY29uc3QgZ2V0Q29va2llID0gKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIFxuICBjb25zdCBuYW1lRVEgPSBuYW1lICsgXCI9XCI7XG4gIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYyA9IGNhW2ldO1xuICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGRlbGV0ZUNvb2tpZSA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDOyBwYXRoPS87YDtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCkgPT4ge1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0F1dGhlbnRpY2F0ZWQsIHNldElzQXV0aGVudGljYXRlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBhdXRoIHN0YXRlIGZyb20gY29va2llc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0Q29va2llKFwidG9rZW5cIik7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0Q29va2llKFwidXNlcklkXCIpO1xuICAgIGNvbnN0IGVtYWlsVmVyaWZpZWQgPSBnZXRDb29raWUoXCJlbWFpbFZlcmlmaWVkXCIpO1xuICAgIFxuICAgIGlmICh0b2tlbiAmJiB1c2VySWQpIHtcbiAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgIC8vIFRyeSB0byBnZXQgdXNlciBkYXRhIGZyb20gY29va2llIG9yIGZldGNoIGZyb20gQVBJXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IHtcbiAgICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgICAgZW1haWxWZXJpZmllZDogZW1haWxWZXJpZmllZCA9PT0gXCJ0cnVlXCJcbiAgICAgIH07XG4gICAgICBzZXRVc2VyKHVzZXJEYXRhIGFzIFVzZXIpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gIGNvbnN0IGdldFVzZXJJZCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBnZXRDb29raWUoXCJ1c2VySWRcIikgfHwgXCJcIjtcbiAgfTtcblxuICBjb25zdCBnZXRUb2tlbiA9ICgpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgICByZXR1cm4gZ2V0Q29va2llKFwidG9rZW5cIik7XG4gIH07XG5cbiAgY29uc3Qgc2V0QXV0aGVudGljYXRpb25TdGF0ZSA9ICh1c2VyRGF0YTogVXNlciwgdG9rZW46IHN0cmluZykgPT4ge1xuICAgIHNldFVzZXIodXNlckRhdGEpO1xuICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICBzZXRDb29raWUoXCJ0b2tlblwiLCB0b2tlbiwgNyk7IC8vIDcgZGF5c1xuICAgIHNldENvb2tpZShcInVzZXJJZFwiLCB1c2VyRGF0YS5pZCwgNyk7XG4gICAgc2V0Q29va2llKFwiZW1haWxWZXJpZmllZFwiLCB1c2VyRGF0YS5lbWFpbFZlcmlmaWVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIDcpO1xuICB9O1xuXG4gIC8vIEF1dGggZnVuY3Rpb25zXG4gIGNvbnN0IHNpZ25JbiA9IGFzeW5jIChjcmVkZW50aWFsczogQ3JlZGVudGlhbHMpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBsb2dpbihjcmVkZW50aWFscyk7XG4gICAgICBpZiAoZGF0YS50b2tlbikge1xuICAgICAgICBzZXRBdXRoZW50aWNhdGlvblN0YXRlKGRhdGEudXNlciwgZGF0YS50b2tlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkxvZ2luIGZhaWxlZFwiO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdmVyaWZ5RW1haWwgPSBhc3luYyAoZW1haWw6IHN0cmluZywgb3RwOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB2ZXJpZnlPVFAoeyBlbWFpbCwgb3RwIH0pO1xuICAgICAgaWYgKGRhdGEudG9rZW4pIHtcbiAgICAgICAgc2V0QXV0aGVudGljYXRpb25TdGF0ZShkYXRhLnVzZXIsIGRhdGEudG9rZW4pO1xuICAgICAgICAvLyBDbGVhciB0ZW1wIGNvb2tpZXMgaWYgdGhleSBleGlzdFxuICAgICAgICBkZWxldGVDb29raWUoXCJ0ZW1wVG9rZW5cIik7XG4gICAgICAgIGRlbGV0ZUNvb2tpZShcInRlbXBVc2VySWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIk9UUCB2ZXJpZmljYXRpb24gZmFpbGVkXCI7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWdpc3RlciA9IGFzeW5jICh1c2VyRGF0YTogVXNlckRhdGEpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaWdudXAodXNlckRhdGEpO1xuICAgICAgaWYgKGRhdGEudG9rZW4pIHtcbiAgICAgICAgc2V0Q29va2llKFwidG9rZW5cIiwgZGF0YS50b2tlbiwgMSk7IC8vIFN0b3JlIHRva2VuIGluIGNvb2tpZXMgZm9yIDEgZGF5XG4gICAgICAgIHNldENvb2tpZShcInVzZXJJZFwiLCBkYXRhLnVzZXIuaWQsIDEpOyAvLyBTdG9yZSB1c2VySWQgaW4gY29va2llcyBmb3IgMSBkYXlcbiAgICAgICAgc2V0VXNlcihkYXRhLnVzZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJSZWdpc3RyYXRpb24gZmFpbGVkXCI7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbmhhbmNlZCBzaWdudXAgZmxvdyB3aXRoIGNvbXByZWhlbnNpdmUgZGF0YVxuICBjb25zdCByZWdpc3RlcldpdGhGbG93ID0gYXN5bmMgKHVzZXJEYXRhOiBhbnkpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaWdudXBGbG93KHVzZXJEYXRhKTtcbiAgICAgIGlmIChkYXRhLnRva2VuKSB7XG4gICAgICAgIC8vIERvbid0IHNldCBhdXRoZW50aWNhdGVkIHN0YXRlIHlldCAtIHVzZXIgbmVlZHMgZW1haWwgdmVyaWZpY2F0aW9uXG4gICAgICAgIHNldENvb2tpZShcInRlbXBUb2tlblwiLCBkYXRhLnRva2VuLCAxKTtcbiAgICAgICAgc2V0Q29va2llKFwidGVtcFVzZXJJZFwiLCBkYXRhLnVzZXI/LmlkIHx8IFwiXCIsIDEpO1xuICAgICAgICBzZXRVc2VyKGRhdGEudXNlciBhcyBVc2VyIHx8IG51bGwpO1xuICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpOyAvLyBSZXF1aXJlcyBlbWFpbCB2ZXJpZmljYXRpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiUmVnaXN0cmF0aW9uIGZhaWxlZFwiO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VuZCBPVFAgZm9yIHZhcmlvdXMgcHVycG9zZXNcbiAgY29uc3Qgc2VuZE9UUENvZGUgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcHVycG9zZTogJ0xPR0lOJyB8ICdWRVJJRllfRU1BSUwnIHwgJ1BBU1NXT1JEX1JFU0VUJyA9ICdMT0dJTicpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzZW5kT1RQKGVtYWlsLCBwdXJwb3NlKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIHNlbmQgT1RQXCI7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBHZXQgZW5oYW5jZWQgdXNlciBwcm9maWxlXG4gIGNvbnN0IGdldEVuaGFuY2VkUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRNZSgpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gZmV0Y2ggcHJvZmlsZVwiO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlVXNlciA9IGFzeW5jICh1c2VyRGF0YTogYW55KSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKTsgLy8gVXNlIHV0aWxpdHkgZnVuY3Rpb25cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB1cGRhdGVVc2VyQnlJZCh1c2VySWQsIHVzZXJEYXRhKTtcbiAgICAgIHNldFVzZXIoZGF0YS51c2VyIHx8IGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJVcGRhdGUgZmFpbGVkXCI7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgc2V0VXNlcihudWxsKTtcbiAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIC8vIENsZWFyIGFsbCBhdXRoIGNvb2tpZXNcbiAgICBkZWxldGVDb29raWUoXCJ0b2tlblwiKTtcbiAgICBkZWxldGVDb29raWUoXCJ1c2VySWRcIik7XG4gICAgZGVsZXRlQ29va2llKFwiZW1haWxWZXJpZmllZFwiKTtcbiAgICBkZWxldGVDb29raWUoXCJ0ZW1wVG9rZW5cIik7XG4gICAgZGVsZXRlQ29va2llKFwidGVtcFVzZXJJZFwiKTtcbiAgfTtcblxuICBjb25zdCByZXNldFBhc3N3b3JkID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNldFBhc3N3b3JkU2VydmljZShlbWFpbCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlBhc3N3b3JkIHJlc2V0IGZhaWxlZFwiO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29tcHV0ZWQgcHJvcGVydGllc1xuICBjb25zdCB1c2VyUm9sZSA9IHVzZXI/LnJvbGUgfHwgbnVsbDtcbiAgY29uc3QgYWNjb3VudFR5cGUgPSB1c2VyPy5hY2NvdW50VHlwZSB8fCBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgdXNlcixcbiAgICBpc0F1dGhlbnRpY2F0ZWQsXG4gICAgdXNlclJvbGUsXG4gICAgYWNjb3VudFR5cGUsXG4gICAgZXJyb3IsXG4gICAgaXNMb2FkaW5nLFxuICAgIHNpZ25JbixcbiAgICB2ZXJpZnlFbWFpbCxcbiAgICByZWdpc3RlcixcbiAgICByZWdpc3RlcldpdGhGbG93LFxuICAgIHNlbmRPVFBDb2RlLFxuICAgIGdldEVuaGFuY2VkUHJvZmlsZSxcbiAgICB1cGRhdGVVc2VyLFxuICAgIGdldFVzZXJJZCxcbiAgICBnZXRUb2tlbixcbiAgICBsb2dvdXQsXG4gICAgcmVzZXRQYXNzd29yZCxcbiAgICBzZXRBdXRoZW50aWNhdGlvblN0YXRlXG4gIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImxvZ2luIiwidmVyaWZ5T1RQIiwic2lnbnVwIiwicmVzZXRQYXNzd29yZCIsInJlc2V0UGFzc3dvcmRTZXJ2aWNlIiwic2lnbnVwRmxvdyIsInNlbmRPVFAiLCJnZXRNZSIsInVwZGF0ZVVzZXJCeUlkIiwic2V0Q29va2llIiwibmFtZSIsInZhbHVlIiwiZGF5cyIsImRvY3VtZW50IiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsImNvb2tpZSIsInRvVVRDU3RyaW5nIiwiZ2V0Q29va2llIiwibmFtZUVRIiwiY2EiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJjIiwiY2hhckF0Iiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsImRlbGV0ZUNvb2tpZSIsInVzZUF1dGgiLCJ1c2VyIiwic2V0VXNlciIsImlzQXV0aGVudGljYXRlZCIsInNldElzQXV0aGVudGljYXRlZCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ0b2tlbiIsInVzZXJJZCIsImVtYWlsVmVyaWZpZWQiLCJ1c2VyRGF0YSIsImlkIiwiZ2V0VXNlcklkIiwiZ2V0VG9rZW4iLCJzZXRBdXRoZW50aWNhdGlvblN0YXRlIiwic2lnbkluIiwiY3JlZGVudGlhbHMiLCJkYXRhIiwiZXJyIiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJtZXNzYWdlIiwidmVyaWZ5RW1haWwiLCJlbWFpbCIsIm90cCIsInJlZ2lzdGVyIiwicmVnaXN0ZXJXaXRoRmxvdyIsInNlbmRPVFBDb2RlIiwicHVycG9zZSIsImdldEVuaGFuY2VkUHJvZmlsZSIsInVwZGF0ZVVzZXIiLCJsb2dvdXQiLCJ1c2VyUm9sZSIsInJvbGUiLCJhY2NvdW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/useAuth.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/services/apiClient.ts":
/*!***********************************!*\
  !*** ./lib/services/apiClient.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: process.env.NEXT_PUBLIC_NODE_ENV === \"development\" ? \"https://nesa-africa-backend-7sio.onrender.com\" : process.env.NEXT_PUBLIC_API_BASE_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Enhanced cookie retrieval with debugging\nconst getCookie = (name)=>{\n    if (typeof document === \"undefined\") {\n        console.warn(\"Document is not available (server-side)\");\n        return null;\n    }\n    const cookies = document.cookie.split(\"; \");\n    console.log(\"All cookies:\", cookies); // Debug log\n    for (const cookie of cookies){\n        const [key, value] = cookie.split(\"=\");\n        if (key === name) {\n            console.log(\"Found \".concat(name, \" cookie\")); // Debug log\n            return decodeURIComponent(value);\n        }\n    }\n    console.warn(\"Cookie \".concat(name, \" not found\")); // Debug log\n    return null;\n};\napiClient.interceptors.request.use((config)=>{\n    const token = getCookie(\"token\");\n    const userId = getCookie(\"userId\");\n    console.log(\"Request Interceptor - Token:\", token); // Debug log\n    console.log(\"Request Interceptor - userId:\", userId); // Debug log\n    if (token) {\n        config.headers.Authorization = \"Bearer \".concat(token);\n        console.log(\"Authorization header set with token\"); // Debug log\n    } else {\n        console.warn(\"No token available for authorization\"); // Debug log\n    }\n    return config;\n}, (error)=>{\n    console.error(\"Request Interceptor Error:\", error);\n    return Promise.reject(error);\n});\napiClient.interceptors.response.use((response)=>{\n    console.log(\"Response Interceptor - Success:\", response.config.url, response.status);\n    return response;\n}, (error)=>{\n    var _error_config, _error_response, _error_response1;\n    console.error(\"Response Interceptor - Error:\", {\n        url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url,\n        status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n        message: error.message,\n        response: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data\n    });\n    return Promise.reject(error);\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (apiClient);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9hcGlDbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQTBCO0FBRTFCLE1BQU1DLFlBQVlELDZDQUFLQSxDQUFDRSxNQUFNLENBQUM7SUFDN0JDLFNBQVNDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0Msb0JBQW9CLEtBQUssZ0JBQzFDLGtEQUNBRixPQUFPQSxDQUFDQyxHQUFHLENBQUNFLHdCQUF3QjtJQUN4Q0MsU0FBUztRQUNQLGdCQUFnQjtJQUNsQjtBQUNGO0FBRUEsMkNBQTJDO0FBQzNDLE1BQU1DLFlBQVksQ0FBQ0M7SUFDakIsSUFBSSxPQUFPQyxhQUFhLGFBQWE7UUFDbkNDLFFBQVFDLElBQUksQ0FBQztRQUNiLE9BQU87SUFDVDtJQUVBLE1BQU1DLFVBQVVILFNBQVNJLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDO0lBQ3RDSixRQUFRSyxHQUFHLENBQUMsZ0JBQWdCSCxVQUFVLFlBQVk7SUFFbEQsS0FBSyxNQUFNQyxVQUFVRCxRQUFTO1FBQzVCLE1BQU0sQ0FBQ0ksS0FBS0MsTUFBTSxHQUFHSixPQUFPQyxLQUFLLENBQUM7UUFDbEMsSUFBSUUsUUFBUVIsTUFBTTtZQUNoQkUsUUFBUUssR0FBRyxDQUFDLFNBQWMsT0FBTFAsTUFBSyxhQUFXLFlBQVk7WUFDakQsT0FBT1UsbUJBQW1CRDtRQUM1QjtJQUNGO0lBRUFQLFFBQVFDLElBQUksQ0FBQyxVQUFlLE9BQUxILE1BQUssZ0JBQWMsWUFBWTtJQUN0RCxPQUFPO0FBQ1Q7QUFFQVQsVUFBVW9CLFlBQVksQ0FBQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBQ0M7SUFDbEMsTUFBTUMsUUFBUWhCLFVBQVU7SUFDeEIsTUFBTWlCLFNBQVNqQixVQUFVO0lBQ3pCRyxRQUFRSyxHQUFHLENBQUMsZ0NBQWdDUSxRQUFRLFlBQVk7SUFDaEViLFFBQVFLLEdBQUcsQ0FBQyxpQ0FBaUNTLFNBQVMsWUFBWTtJQUVsRSxJQUFJRCxPQUFPO1FBQ1RELE9BQU9oQixPQUFPLENBQUNtQixhQUFhLEdBQUcsVUFBZ0IsT0FBTkY7UUFDekNiLFFBQVFLLEdBQUcsQ0FBQyx3Q0FBd0MsWUFBWTtJQUNsRSxPQUFPO1FBQ0xMLFFBQVFDLElBQUksQ0FBQyx5Q0FBeUMsWUFBWTtJQUNwRTtJQUVBLE9BQU9XO0FBQ1QsR0FBRyxDQUFDSTtJQUNGaEIsUUFBUWdCLEtBQUssQ0FBQyw4QkFBOEJBO0lBQzVDLE9BQU9DLFFBQVFDLE1BQU0sQ0FBQ0Y7QUFDeEI7QUFFQTNCLFVBQVVvQixZQUFZLENBQUNVLFFBQVEsQ0FBQ1IsR0FBRyxDQUFDLENBQUNRO0lBQ25DbkIsUUFBUUssR0FBRyxDQUFDLG1DQUFtQ2MsU0FBU1AsTUFBTSxDQUFDUSxHQUFHLEVBQUVELFNBQVNFLE1BQU07SUFDbkYsT0FBT0Y7QUFDVCxHQUFHLENBQUNIO1FBRUtBLGVBQ0dBLGlCQUVFQTtJQUpaaEIsUUFBUWdCLEtBQUssQ0FBQyxpQ0FBaUM7UUFDN0NJLEdBQUcsR0FBRUosZ0JBQUFBLE1BQU1KLE1BQU0sY0FBWkksb0NBQUFBLGNBQWNJLEdBQUc7UUFDdEJDLE1BQU0sR0FBRUwsa0JBQUFBLE1BQU1HLFFBQVEsY0FBZEgsc0NBQUFBLGdCQUFnQkssTUFBTTtRQUM5QkMsU0FBU04sTUFBTU0sT0FBTztRQUN0QkgsUUFBUSxHQUFFSCxtQkFBQUEsTUFBTUcsUUFBUSxjQUFkSCx1Q0FBQUEsaUJBQWdCTyxJQUFJO0lBQ2hDO0lBQ0EsT0FBT04sUUFBUUMsTUFBTSxDQUFDRjtBQUN4QjtBQUVBLCtEQUFlM0IsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc2VydmljZXMvYXBpQ2xpZW50LnRzP2UzZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuXG5jb25zdCBhcGlDbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICBiYXNlVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyBcbiAgICA/ICdodHRwczovL25lc2EtYWZyaWNhLWJhY2tlbmQtN3Npby5vbnJlbmRlci5jb20nIFxuICAgIDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMLFxuICBoZWFkZXJzOiB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIH0sXG59KTtcblxuLy8gRW5oYW5jZWQgY29va2llIHJldHJpZXZhbCB3aXRoIGRlYnVnZ2luZ1xuY29uc3QgZ2V0Q29va2llID0gKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUud2FybignRG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZSAoc2VydmVyLXNpZGUpJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7ICcpO1xuICBjb25zb2xlLmxvZygnQWxsIGNvb2tpZXM6JywgY29va2llcyk7IC8vIERlYnVnIGxvZ1xuICBcbiAgZm9yIChjb25zdCBjb29raWUgb2YgY29va2llcykge1xuICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGNvb2tpZS5zcGxpdCgnPScpO1xuICAgIGlmIChrZXkgPT09IG5hbWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke25hbWV9IGNvb2tpZWApOyAvLyBEZWJ1ZyBsb2dcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc29sZS53YXJuKGBDb29raWUgJHtuYW1lfSBub3QgZm91bmRgKTsgLy8gRGVidWcgbG9nXG4gIHJldHVybiBudWxsO1xufTtcblxuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZSgoY29uZmlnKSA9PiB7XG4gIGNvbnN0IHRva2VuID0gZ2V0Q29va2llKCd0b2tlbicpO1xuICBjb25zdCB1c2VySWQgPSBnZXRDb29raWUoJ3VzZXJJZCcpO1xuICBjb25zb2xlLmxvZygnUmVxdWVzdCBJbnRlcmNlcHRvciAtIFRva2VuOicsIHRva2VuKTsgLy8gRGVidWcgbG9nXG4gIGNvbnNvbGUubG9nKCdSZXF1ZXN0IEludGVyY2VwdG9yIC0gdXNlcklkOicsIHVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICBcbiAgaWYgKHRva2VuKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIGNvbnNvbGUubG9nKCdBdXRob3JpemF0aW9uIGhlYWRlciBzZXQgd2l0aCB0b2tlbicpOyAvLyBEZWJ1ZyBsb2dcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ05vIHRva2VuIGF2YWlsYWJsZSBmb3IgYXV0aG9yaXphdGlvbicpOyAvLyBEZWJ1ZyBsb2dcbiAgfVxuICBcbiAgcmV0dXJuIGNvbmZpZztcbn0sIChlcnJvcikgPT4ge1xuICBjb25zb2xlLmVycm9yKCdSZXF1ZXN0IEludGVyY2VwdG9yIEVycm9yOicsIGVycm9yKTtcbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbn0pO1xuXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZSgocmVzcG9uc2UpID0+IHtcbiAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIEludGVyY2VwdG9yIC0gU3VjY2VzczonLCByZXNwb25zZS5jb25maWcudXJsLCByZXNwb25zZS5zdGF0dXMpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59LCAoZXJyb3IpID0+IHtcbiAgY29uc29sZS5lcnJvcignUmVzcG9uc2UgSW50ZXJjZXB0b3IgLSBFcnJvcjonLCB7XG4gICAgdXJsOiBlcnJvci5jb25maWc/LnVybCxcbiAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICByZXNwb25zZTogZXJyb3IucmVzcG9uc2U/LmRhdGFcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpQ2xpZW50OyJdLCJuYW1lcyI6WyJheGlvcyIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTk9ERV9FTlYiLCJORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwiLCJoZWFkZXJzIiwiZ2V0Q29va2llIiwibmFtZSIsImRvY3VtZW50IiwiY29uc29sZSIsIndhcm4iLCJjb29raWVzIiwiY29va2llIiwic3BsaXQiLCJsb2ciLCJrZXkiLCJ2YWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsInVzZXJJZCIsIkF1dGhvcml6YXRpb24iLCJlcnJvciIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNwb25zZSIsInVybCIsInN0YXR1cyIsIm1lc3NhZ2UiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/apiClient.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/services/authService.ts":
/*!*************************************!*\
  !*** ./lib/services/authService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changePassword: function() { return /* binding */ changePassword; },\n/* harmony export */   checkEmailAvailability: function() { return /* binding */ checkEmailAvailability; },\n/* harmony export */   getMe: function() { return /* binding */ getMe; },\n/* harmony export */   login: function() { return /* binding */ login; },\n/* harmony export */   resendOtp: function() { return /* binding */ resendOtp; },\n/* harmony export */   resetPassword: function() { return /* binding */ resetPassword; },\n/* harmony export */   sendOTP: function() { return /* binding */ sendOTP; },\n/* harmony export */   signup: function() { return /* binding */ signup; },\n/* harmony export */   signupFlow: function() { return /* binding */ signupFlow; },\n/* harmony export */   verifyOTP: function() { return /* binding */ verifyOTP; },\n/* harmony export */   verifyOtp: function() { return /* binding */ verifyOtp; }\n/* harmony export */ });\n/* harmony import */ var _apiClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiClient */ \"(app-pages-browser)/./lib/services/apiClient.ts\");\n/* harmony import */ var _lib_utils_signupMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/utils/signupMapping */ \"(app-pages-browser)/./lib/utils/signupMapping.ts\");\n// authService.ts\n\n\nconst login = async (credentials)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/login\", credentials);\n        // Handle enhanced response structure\n        if (response.data.success && response.data.data) {\n            var _response_data_data_tokens;\n            return {\n                message: response.data.message,\n                token: (_response_data_data_tokens = response.data.data.tokens) === null || _response_data_data_tokens === void 0 ? void 0 : _response_data_data_tokens.accessToken,\n                user: response.data.data.user\n            };\n        }\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"Invalid email or password\");\n        throw new Error(message);\n    }\n};\nconst verifyOTP = async (data)=>{\n    try {\n        // Transform frontend data to match backend expectations\n        const backendData = {\n            email: data.email,\n            code: data.otp,\n            purpose: \"LOGIN\" // Default purpose for login flow\n        };\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/otp/verify\", backendData);\n        // Handle enhanced response structure\n        if (response.data.success && response.data.data) {\n            var _response_data_data_tokens;\n            return {\n                message: response.data.message,\n                token: (_response_data_data_tokens = response.data.data.tokens) === null || _response_data_data_tokens === void 0 ? void 0 : _response_data_data_tokens.accessToken,\n                user: response.data.data.user || response.data.data.profile\n            };\n        }\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"OTP verification failed\");\n        throw new Error(message);\n    }\n};\nconst signup = async (userData)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/signup\", userData);\n        // Handle enhanced response structure\n        if (response.data.success && response.data.data) {\n            var _response_data_data_tokens;\n            return {\n                message: response.data.message,\n                token: (_response_data_data_tokens = response.data.data.tokens) === null || _response_data_data_tokens === void 0 ? void 0 : _response_data_data_tokens.accessToken,\n                user: response.data.data.user\n            };\n        }\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"Registration failed\");\n        throw new Error(message);\n    }\n};\nconst changePassword = async (data)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/password/change\", data);\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"Password change failed\");\n        throw new Error(message);\n    }\n};\nconst resetPassword = async (email)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/password-reset/request\", {\n            email\n        });\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"Failed to reset password\");\n        throw new Error(message);\n    }\n};\n// Legacy signup flow - removed duplicate, using the comprehensive one below\n// Send OTP for different purposes - using enhanced endpoints\nconst sendOTP = async function(email) {\n    let purpose = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"LOGIN\";\n    try {\n        // Use specific enhanced endpoints based on purpose\n        let endpoint = \"/api/v1/auth/otp/send-login\"; // Default for login\n        if (purpose === \"VERIFY_EMAIL\") {\n            endpoint = \"/api/v1/auth/otp/send-verify-email\";\n        } else if (purpose === \"PASSWORD_RESET\") {\n            endpoint = \"/api/v1/auth/password-reset/send-otp\";\n        }\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(endpoint, {\n            email\n        });\n        if (response.data.success) {\n            return {\n                message: response.data.message\n            };\n        }\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"Failed to send OTP\");\n        throw new Error(message);\n    }\n};\n// Get enhanced user profile with wallet and chapter data\nconst getMe = async ()=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"/api/v1/auth/me\");\n        if (response.data.success) {\n            return response.data.data;\n        }\n        return response.data;\n    } catch (error) {\n        const message = extractErrorMessage(error, \"Failed to fetch profile\");\n        throw new Error(message);\n    }\n};\n// Helper function to safely extract error messages\nconst extractErrorMessage = (error, fallback)=>{\n    var _error_response_data, _error_response;\n    if (typeof error === \"object\" && error !== null && \"response\" in error && typeof ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) === \"string\") {\n        return error.response.data.message;\n    }\n    if (error instanceof Error) return error.message;\n    return fallback;\n};\n// Comprehensive signup flow for NESA platform\nconst signupFlow = async (userData)=>{\n    try {\n        // Map frontend data to backend format\n        const backendData = (0,_lib_utils_signupMapping__WEBPACK_IMPORTED_MODULE_1__.mapFormDataToBackend)(userData);\n        // Call backend signup-flow endpoint with correct path\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/signup-flow\", backendData);\n        // Map backend response to frontend format\n        return (0,_lib_utils_signupMapping__WEBPACK_IMPORTED_MODULE_1__.mapBackendResponseToFrontend)(response);\n    } catch (error) {\n        console.error(\"Signup flow failed:\", error);\n        throw new Error(error instanceof Error ? error.message : \"Signup failed\");\n    }\n};\n// OTP verification for email verification - using enhanced endpoint\nconst verifyOtp = async function(email, otp) {\n    let purpose = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"VERIFY_EMAIL\";\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/otp/verify\", {\n            email,\n            code: otp,\n            purpose\n        });\n        return response;\n    } catch (error) {\n        console.error(\"OTP verification failed:\", error);\n        throw error;\n    }\n};\n// Resend OTP - using enhanced endpoint\nconst resendOtp = async function(email) {\n    let purpose = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"VERIFY_EMAIL\";\n    try {\n        // Select the appropriate endpoint based on purpose\n        let endpoint = \"/api/v1/auth/otp/send-login\"; // Default for login\n        if (purpose === \"VERIFY_EMAIL\") {\n            endpoint = \"/api/v1/auth/otp/send-verify-email\";\n        } else if (purpose === \"PASSWORD_RESET\") {\n            endpoint = \"/api/v1/auth/password-reset/send-otp\";\n        }\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(endpoint, {\n            email\n        });\n        return response;\n    } catch (error) {\n        console.error(\"Resend OTP failed:\", error);\n        throw error;\n    }\n};\n// Check email availability - using enhanced endpoint\nconst checkEmailAvailability = async (email)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"/api/v1/auth/check-email\", {\n            email\n        });\n        return response.data;\n    } catch (error) {\n        // If email check fails, assume it's available (graceful degradation)\n        console.warn(\"Email availability check failed:\", error);\n        return {\n            available: true\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9hdXRoU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQ21CO0FBRTJEO0FBb0R4RixNQUFNRyxRQUFRLE9BQU9DO0lBQzFCLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1MLGtEQUFTQSxDQUFDTSxJQUFJLENBQUMsc0JBQXNCRjtRQUU1RCxxQ0FBcUM7UUFDckMsSUFBSUMsU0FBU0UsSUFBSSxDQUFDQyxPQUFPLElBQUlILFNBQVNFLElBQUksQ0FBQ0EsSUFBSSxFQUFFO2dCQUd0Q0Y7WUFGVCxPQUFPO2dCQUNMSSxTQUFTSixTQUFTRSxJQUFJLENBQUNFLE9BQU87Z0JBQzlCQyxLQUFLLEdBQUVMLDZCQUFBQSxTQUFTRSxJQUFJLENBQUNBLElBQUksQ0FBQ0ksTUFBTSxjQUF6Qk4saURBQUFBLDJCQUEyQk8sV0FBVztnQkFDN0NDLE1BQU1SLFNBQVNFLElBQUksQ0FBQ0EsSUFBSSxDQUFDTSxJQUFJO1lBQy9CO1FBQ0Y7UUFFQSxPQUFPUixTQUFTRSxJQUFJO0lBQ3RCLEVBQUUsT0FBT08sT0FBZ0I7UUFDdkIsTUFBTUwsVUFBVU0sb0JBQW9CRCxPQUFPO1FBQzNDLE1BQU0sSUFBSUUsTUFBTVA7SUFDbEI7QUFDRixFQUFFO0FBRUssTUFBTVEsWUFBWSxPQUFPVjtJQUM5QixJQUFJO1FBQ0Ysd0RBQXdEO1FBQ3hELE1BQU1XLGNBQWM7WUFDbEJDLE9BQU9aLEtBQUtZLEtBQUs7WUFDakJDLE1BQU1iLEtBQUtjLEdBQUc7WUFDZEMsU0FBUyxRQUFRLGlDQUFpQztRQUNwRDtRQUVBLE1BQU1qQixXQUFXLE1BQU1MLGtEQUFTQSxDQUFDTSxJQUFJLENBQUMsMkJBQTJCWTtRQUVqRSxxQ0FBcUM7UUFDckMsSUFBSWIsU0FBU0UsSUFBSSxDQUFDQyxPQUFPLElBQUlILFNBQVNFLElBQUksQ0FBQ0EsSUFBSSxFQUFFO2dCQUd0Q0Y7WUFGVCxPQUFPO2dCQUNM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QUEyQjtZQUMvRGE7WUFDQUMsTUFBTUM7WUFDTkM7UUFDRjtRQUNBLE9BQU9qQjtJQUNULEVBQUUsT0FBT1MsT0FBTztRQUNkb0IsUUFBUXBCLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE1BQU1BO0lBQ1I7QUFDRixFQUFFO0FBRUYsdUNBQXVDO0FBQ2hDLE1BQU1zQixZQUFZLGVBQU9qQjtRQUFlRywyRUFBa0I7SUFDL0QsSUFBSTtRQUNGLG1EQUFtRDtRQUNuRCxJQUFJTyxXQUFXLCtCQUErQixvQkFBb0I7UUFFbEUsSUFBSVAsWUFBWSxnQkFBZ0I7WUFDOUJPLFdBQVc7UUFDYixPQUFPLElBQUlQLFlBQVksa0JBQWtCO1lBQ3ZDTyxXQUFXO1FBQ2I7UUFFQSxNQUFNeEIsV0FBVyxNQUFNTCxrREFBU0EsQ0FBQ00sSUFBSSxDQUFDdUIsVUFBVTtZQUFFVjtRQUFNO1FBQ3hELE9BQU9kO0lBQ1QsRUFBRSxPQUFPUyxPQUFPO1FBQ2RvQixRQUFRcEIsS0FBSyxDQUFDLHNCQUFzQkE7UUFDcEMsTUFBTUE7SUFDUjtBQUNGLEVBQUU7QUFFRixxREFBcUQ7QUFDOUMsTUFBTXVCLHlCQUF5QixPQUFPbEI7SUFDM0MsSUFBSTtRQUNGLE1BQU1kLFdBQVcsTUFBTUwsa0RBQVNBLENBQUNNLElBQUksQ0FBQyw0QkFBNEI7WUFBRWE7UUFBTTtRQUMxRSxPQUFPZCxTQUFTRSxJQUFJO0lBQ3RCLEVBQUUsT0FBT08sT0FBTztRQUNkLHFFQUFxRTtRQUNyRW9CLFFBQVFJLElBQUksQ0FBQyxvQ0FBb0N4QjtRQUNqRCxPQUFPO1lBQUV5QixXQUFXO1FBQUs7SUFDM0I7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9zZXJ2aWNlcy9hdXRoU2VydmljZS50cz80ZmNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGF1dGhTZXJ2aWNlLnRzXG5pbXBvcnQgYXBpQ2xpZW50IGZyb20gJy4vYXBpQ2xpZW50JztcbmltcG9ydCB7IFNpZ251cEZvcm1EYXRhLCBTaWdudXBSZXNwb25zZSB9IGZyb20gJ0AvbGliL3R5cGVzL3NpZ251cCc7XG5pbXBvcnQgeyBtYXBGb3JtRGF0YVRvQmFja2VuZCwgbWFwQmFja2VuZFJlc3BvbnNlVG9Gcm9udGVuZCB9IGZyb20gJ0AvbGliL3V0aWxzL3NpZ251cE1hcHBpbmcnO1xuXG5pbnRlcmZhY2UgQ3JlZGVudGlhbHMge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT1RQRGF0YSB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG90cDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVXNlckRhdGEge1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICBub21pbmVlVHlwZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICByb2xlOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIHJlZ2lvbjogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBpbWFnZT86IHN0cmluZztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5pbnRlcmZhY2UgQXV0aFJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB0b2tlbj86IHN0cmluZztcbiAgdXNlcjoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIENoYW5nZVBhc3N3b3JkRGF0YSB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG9sZFBhc3N3b3JkOiBzdHJpbmc7XG4gIG5ld1Bhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBDaGFuZ2VQYXNzd29yZFJlc3BvbnNlIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlc2V0UGFzc3dvcmRSZXNwb25zZSB7XG4gIHN0YXR1czogbnVtYmVyO1xuICBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBsb2dpbiA9IGFzeW5jIChjcmVkZW50aWFsczogQ3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvdjEvYXV0aC9sb2dpbicsIGNyZWRlbnRpYWxzKTtcbiAgICBcbiAgICAvLyBIYW5kbGUgZW5oYW5jZWQgcmVzcG9uc2Ugc3RydWN0dXJlXG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhLmRhdGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLmRhdGEubWVzc2FnZSxcbiAgICAgICAgdG9rZW46IHJlc3BvbnNlLmRhdGEuZGF0YS50b2tlbnM/LmFjY2Vzc1Rva2VuLFxuICAgICAgICB1c2VyOiByZXNwb25zZS5kYXRhLmRhdGEudXNlclxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5T1RQID0gYXN5bmMgKGRhdGE6IE9UUERhdGEpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIC8vIFRyYW5zZm9ybSBmcm9udGVuZCBkYXRhIHRvIG1hdGNoIGJhY2tlbmQgZXhwZWN0YXRpb25zXG4gICAgY29uc3QgYmFja2VuZERhdGEgPSB7XG4gICAgICBlbWFpbDogZGF0YS5lbWFpbCxcbiAgICAgIGNvZGU6IGRhdGEub3RwLCAvLyBCYWNrZW5kIGV4cGVjdHMgJ2NvZGUnIG5vdCAnb3RwJ1xuICAgICAgcHVycG9zZTogJ0xPR0lOJyAvLyBEZWZhdWx0IHB1cnBvc2UgZm9yIGxvZ2luIGZsb3dcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvdjEvYXV0aC9vdHAvdmVyaWZ5JywgYmFja2VuZERhdGEpO1xuICAgIFxuICAgIC8vIEhhbmRsZSBlbmhhbmNlZCByZXNwb25zZSBzdHJ1Y3R1cmVcbiAgICBpZiAocmVzcG9uc2UuZGF0YS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEuZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UuZGF0YS5tZXNzYWdlLFxuICAgICAgICB0b2tlbjogcmVzcG9uc2UuZGF0YS5kYXRhLnRva2Vucz8uYWNjZXNzVG9rZW4sXG4gICAgICAgIHVzZXI6IHJlc3BvbnNlLmRhdGEuZGF0YS51c2VyIHx8IHJlc3BvbnNlLmRhdGEuZGF0YS5wcm9maWxlXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXh0cmFjdEVycm9yTWVzc2FnZShlcnJvciwgJ09UUCB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2lnbnVwID0gYXN5bmMgKHVzZXJEYXRhOiBVc2VyRGF0YSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS92MS9hdXRoL3NpZ251cCcsIHVzZXJEYXRhKTtcbiAgICBcbiAgICAvLyBIYW5kbGUgZW5oYW5jZWQgcmVzcG9uc2Ugc3RydWN0dXJlXG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhLmRhdGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLmRhdGEubWVzc2FnZSxcbiAgICAgICAgdG9rZW46IHJlc3BvbnNlLmRhdGEuZGF0YS50b2tlbnM/LmFjY2Vzc1Rva2VuLFxuICAgICAgICB1c2VyOiByZXNwb25zZS5kYXRhLmRhdGEudXNlclxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdSZWdpc3RyYXRpb24gZmFpbGVkJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY2hhbmdlUGFzc3dvcmQgPSBhc3luYyAoZGF0YTogQ2hhbmdlUGFzc3dvcmREYXRhKTogUHJvbWlzZTxDaGFuZ2VQYXNzd29yZFJlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS92MS9hdXRoL3Bhc3N3b3JkL2NoYW5nZScsIGRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnUGFzc3dvcmQgY2hhbmdlIGZhaWxlZCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlc2V0UGFzc3dvcmQgPSBhc3luYyAoZW1haWw6IHN0cmluZyk6IFByb21pc2U8UmVzZXRQYXNzd29yZFJlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS92MS9hdXRoL3Bhc3N3b3JkLXJlc2V0L3JlcXVlc3QnLCB7IGVtYWlsIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnRmFpbGVkIHRvIHJlc2V0IHBhc3N3b3JkJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vLyBMZWdhY3kgc2lnbnVwIGZsb3cgLSByZW1vdmVkIGR1cGxpY2F0ZSwgdXNpbmcgdGhlIGNvbXByZWhlbnNpdmUgb25lIGJlbG93XG5cbi8vIFNlbmQgT1RQIGZvciBkaWZmZXJlbnQgcHVycG9zZXMgLSB1c2luZyBlbmhhbmNlZCBlbmRwb2ludHNcbmV4cG9ydCBjb25zdCBzZW5kT1RQID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHB1cnBvc2U6ICdMT0dJTicgfCAnVkVSSUZZX0VNQUlMJyB8ICdQQVNTV09SRF9SRVNFVCcgPSAnTE9HSU4nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHNwZWNpZmljIGVuaGFuY2VkIGVuZHBvaW50cyBiYXNlZCBvbiBwdXJwb3NlXG4gICAgbGV0IGVuZHBvaW50ID0gJy9hcGkvdjEvYXV0aC9vdHAvc2VuZC1sb2dpbic7IC8vIERlZmF1bHQgZm9yIGxvZ2luXG4gICAgXG4gICAgaWYgKHB1cnBvc2UgPT09ICdWRVJJRllfRU1BSUwnKSB7XG4gICAgICBlbmRwb2ludCA9ICcvYXBpL3YxL2F1dGgvb3RwL3NlbmQtdmVyaWZ5LWVtYWlsJztcbiAgICB9IGVsc2UgaWYgKHB1cnBvc2UgPT09ICdQQVNTV09SRF9SRVNFVCcpIHtcbiAgICAgIGVuZHBvaW50ID0gJy9hcGkvdjEvYXV0aC9wYXNzd29yZC1yZXNldC9zZW5kLW90cCc7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoZW5kcG9pbnQsIHsgZW1haWwgfSk7XG4gICAgXG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogcmVzcG9uc2UuZGF0YS5tZXNzYWdlIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnRmFpbGVkIHRvIHNlbmQgT1RQJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vLyBHZXQgZW5oYW5jZWQgdXNlciBwcm9maWxlIHdpdGggd2FsbGV0IGFuZCBjaGFwdGVyIGRhdGFcbmV4cG9ydCBjb25zdCBnZXRNZSA9IGFzeW5jICgpOiBQcm9taXNlPGFueT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL2FwaS92MS9hdXRoL21lJyk7XG4gICAgXG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdGYWlsZWQgdG8gZmV0Y2ggcHJvZmlsZScpO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhZmVseSBleHRyYWN0IGVycm9yIG1lc3NhZ2VzXG5jb25zdCBleHRyYWN0RXJyb3JNZXNzYWdlID0gKGVycm9yOiB1bmtub3duLCBmYWxsYmFjazogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgaWYgKFxuICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICdyZXNwb25zZScgaW4gZXJyb3IgJiZcbiAgICB0eXBlb2YgKGVycm9yIGFzIGFueSkucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiAoZXJyb3IgYXMgYW55KS5yZXNwb25zZS5kYXRhLm1lc3NhZ2U7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICByZXR1cm4gZmFsbGJhY2s7XG59O1xuXG4vLyBDb21wcmVoZW5zaXZlIHNpZ251cCBmbG93IGZvciBORVNBIHBsYXRmb3JtXG5leHBvcnQgY29uc3Qgc2lnbnVwRmxvdyA9IGFzeW5jICh1c2VyRGF0YTogU2lnbnVwRm9ybURhdGEpOiBQcm9taXNlPFNpZ251cFJlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gTWFwIGZyb250ZW5kIGRhdGEgdG8gYmFja2VuZCBmb3JtYXRcbiAgICBjb25zdCBiYWNrZW5kRGF0YSA9IG1hcEZvcm1EYXRhVG9CYWNrZW5kKHVzZXJEYXRhKTtcblxuICAgIC8vIENhbGwgYmFja2VuZCBzaWdudXAtZmxvdyBlbmRwb2ludCB3aXRoIGNvcnJlY3QgcGF0aFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvdjEvYXV0aC9zaWdudXAtZmxvdycsIGJhY2tlbmREYXRhKTtcblxuICAgIC8vIE1hcCBiYWNrZW5kIHJlc3BvbnNlIHRvIGZyb250ZW5kIGZvcm1hdFxuICAgIHJldHVybiBtYXBCYWNrZW5kUmVzcG9uc2VUb0Zyb250ZW5kKHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTaWdudXAgZmxvdyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdTaWdudXAgZmFpbGVkJyk7XG4gIH1cbn07XG5cbi8vIE9UUCB2ZXJpZmljYXRpb24gZm9yIGVtYWlsIHZlcmlmaWNhdGlvbiAtIHVzaW5nIGVuaGFuY2VkIGVuZHBvaW50XG5leHBvcnQgY29uc3QgdmVyaWZ5T3RwID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIG90cDogc3RyaW5nLCBwdXJwb3NlOiBzdHJpbmcgPSAnVkVSSUZZX0VNQUlMJyk6IFByb21pc2U8YW55PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS92MS9hdXRoL290cC92ZXJpZnknLCB7IFxuICAgICAgZW1haWwsIFxuICAgICAgY29kZTogb3RwLCAvLyBCYWNrZW5kIGV4cGVjdHMgJ2NvZGUnIG5vdCAnb3RwJ1xuICAgICAgcHVycG9zZSBcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignT1RQIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBSZXNlbmQgT1RQIC0gdXNpbmcgZW5oYW5jZWQgZW5kcG9pbnRcbmV4cG9ydCBjb25zdCByZXNlbmRPdHAgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcHVycG9zZTogc3RyaW5nID0gJ1ZFUklGWV9FTUFJTCcpOiBQcm9taXNlPGFueT4gPT4ge1xuICB0cnkge1xuICAgIC8vIFNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgZW5kcG9pbnQgYmFzZWQgb24gcHVycG9zZVxuICAgIGxldCBlbmRwb2ludCA9ICcvYXBpL3YxL2F1dGgvb3RwL3NlbmQtbG9naW4nOyAvLyBEZWZhdWx0IGZvciBsb2dpblxuICAgIFxuICAgIGlmIChwdXJwb3NlID09PSAnVkVSSUZZX0VNQUlMJykge1xuICAgICAgZW5kcG9pbnQgPSAnL2FwaS92MS9hdXRoL290cC9zZW5kLXZlcmlmeS1lbWFpbCc7XG4gICAgfSBlbHNlIGlmIChwdXJwb3NlID09PSAnUEFTU1dPUkRfUkVTRVQnKSB7XG4gICAgICBlbmRwb2ludCA9ICcvYXBpL3YxL2F1dGgvcGFzc3dvcmQtcmVzZXQvc2VuZC1vdHAnO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGVuZHBvaW50LCB7IGVtYWlsIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSZXNlbmQgT1RQIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIENoZWNrIGVtYWlsIGF2YWlsYWJpbGl0eSAtIHVzaW5nIGVuaGFuY2VkIGVuZHBvaW50XG5leHBvcnQgY29uc3QgY2hlY2tFbWFpbEF2YWlsYWJpbGl0eSA9IGFzeW5jIChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx7IGF2YWlsYWJsZTogYm9vbGVhbiB9PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS92MS9hdXRoL2NoZWNrLWVtYWlsJywgeyBlbWFpbCB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiBlbWFpbCBjaGVjayBmYWlscywgYXNzdW1lIGl0J3MgYXZhaWxhYmxlIChncmFjZWZ1bCBkZWdyYWRhdGlvbilcbiAgICBjb25zb2xlLndhcm4oJ0VtYWlsIGF2YWlsYWJpbGl0eSBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHJldHVybiB7IGF2YWlsYWJsZTogdHJ1ZSB9O1xuICB9XG59OyJdLCJuYW1lcyI6WyJhcGlDbGllbnQiLCJtYXBGb3JtRGF0YVRvQmFja2VuZCIsIm1hcEJhY2tlbmRSZXNwb25zZVRvRnJvbnRlbmQiLCJsb2dpbiIsImNyZWRlbnRpYWxzIiwicmVzcG9uc2UiLCJwb3N0IiwiZGF0YSIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidG9rZW4iLCJ0b2tlbnMiLCJhY2Nlc3NUb2tlbiIsInVzZXIiLCJlcnJvciIsImV4dHJhY3RFcnJvck1lc3NhZ2UiLCJFcnJvciIsInZlcmlmeU9UUCIsImJhY2tlbmREYXRhIiwiZW1haWwiLCJjb2RlIiwib3RwIiwicHVycG9zZSIsInByb2ZpbGUiLCJzaWdudXAiLCJ1c2VyRGF0YSIsImNoYW5nZVBhc3N3b3JkIiwicmVzZXRQYXNzd29yZCIsInNlbmRPVFAiLCJlbmRwb2ludCIsImdldE1lIiwiZ2V0IiwiZmFsbGJhY2siLCJzaWdudXBGbG93IiwiY29uc29sZSIsInZlcmlmeU90cCIsInJlc2VuZE90cCIsImNoZWNrRW1haWxBdmFpbGFiaWxpdHkiLCJ3YXJuIiwiYXZhaWxhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/authService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/services/userService.ts":
/*!*************************************!*\
  !*** ./lib/services/userService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUserById: function() { return /* binding */ getUserById; },\n/* harmony export */   updateUserById: function() { return /* binding */ updateUserById; }\n/* harmony export */ });\n/* harmony import */ var _apiClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiClient */ \"(app-pages-browser)/./lib/services/apiClient.ts\");\n\nconst getUserById = async (userId)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"/api/user/\".concat(userId));\n        return response.data;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        const errorMessage = ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message || \"Failed to fetch user details\";\n        throw new Error(errorMessage);\n    }\n};\nconst updateUserById = async (userId, userData)=>{\n    try {\n        const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].put(\"/api/user/update/\".concat(userId), userData);\n        return response.data;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        const errorMessage = ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message || \"Failed to update user details\";\n        throw new Error(errorMessage);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy91c2VyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFFN0IsTUFBTUMsY0FBYyxPQUFPQztJQUNoQyxJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNSCxrREFBU0EsQ0FBQ0ksR0FBRyxDQUFDLGFBQW9CLE9BQVBGO1FBQ2xELE9BQU9DLFNBQVNFLElBQUk7SUFDdEIsRUFBRSxPQUFPQyxPQUFZO1lBQ0VBLHNCQUFBQTtRQUFyQixNQUFNQyxlQUFlRCxFQUFBQSxrQkFBQUEsTUFBTUgsUUFBUSxjQUFkRyx1Q0FBQUEsdUJBQUFBLGdCQUFnQkQsSUFBSSxjQUFwQkMsMkNBQUFBLHFCQUFzQkUsT0FBTyxLQUMvQkYsTUFBTUUsT0FBTyxJQUNiO1FBQ25CLE1BQU0sSUFBSUMsTUFBTUY7SUFDbEI7QUFDRixFQUFFO0FBRUssTUFBTUcsaUJBQWlCLE9BQU9SLFFBQWdCUztJQUNuRCxJQUFJO1FBQ0YsTUFBTVIsV0FBVyxNQUFNSCxrREFBU0EsQ0FBQ1ksR0FBRyxDQUFDLG9CQUEyQixPQUFQVixTQUFVUztRQUNuRSxPQUFPUixTQUFTRSxJQUFJO0lBQ3RCLEVBQUUsT0FBT0MsT0FBWTtZQUNFQSxzQkFBQUE7UUFBckIsTUFBTUMsZUFBZUQsRUFBQUEsa0JBQUFBLE1BQU1ILFFBQVEsY0FBZEcsdUNBQUFBLHVCQUFBQSxnQkFBZ0JELElBQUksY0FBcEJDLDJDQUFBQSxxQkFBc0JFLE9BQU8sS0FDL0JGLE1BQU1FLE9BQU8sSUFDYjtRQUNuQixNQUFNLElBQUlDLE1BQU1GO0lBQ2xCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc2VydmljZXMvdXNlclNlcnZpY2UudHM/NGM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBpQ2xpZW50IGZyb20gJy4vYXBpQ2xpZW50JztcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJCeUlkID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3VzZXIvJHt1c2VySWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZmV0Y2ggdXNlciBkZXRhaWxzJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJCeUlkID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCB1c2VyRGF0YTogYW55KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL3VzZXIvdXBkYXRlLyR7dXNlcklkfWAsIHVzZXJEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byB1cGRhdGUgdXNlciBkZXRhaWxzJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufTsiXSwibmFtZXMiOlsiYXBpQ2xpZW50IiwiZ2V0VXNlckJ5SWQiLCJ1c2VySWQiLCJyZXNwb25zZSIsImdldCIsImRhdGEiLCJlcnJvciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJFcnJvciIsInVwZGF0ZVVzZXJCeUlkIiwidXNlckRhdGEiLCJwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/userService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/utils/signupMapping.ts":
/*!************************************!*\
  !*** ./lib/utils/signupMapping.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getApplicationType: function() { return /* binding */ getApplicationType; },\n/* harmony export */   getDashboardRoute: function() { return /* binding */ getDashboardRoute; },\n/* harmony export */   getPostSignupActions: function() { return /* binding */ getPostSignupActions; },\n/* harmony export */   mapAccountType: function() { return /* binding */ mapAccountType; },\n/* harmony export */   mapBackendResponseToFrontend: function() { return /* binding */ mapBackendResponseToFrontend; },\n/* harmony export */   mapFormDataToBackend: function() { return /* binding */ mapFormDataToBackend; },\n/* harmony export */   mapGender: function() { return /* binding */ mapGender; },\n/* harmony export */   mapIntents: function() { return /* binding */ mapIntents; },\n/* harmony export */   mapLanguage: function() { return /* binding */ mapLanguage; },\n/* harmony export */   requiresApplication: function() { return /* binding */ requiresApplication; },\n/* harmony export */   validateBackendRequirements: function() { return /* binding */ validateBackendRequirements; }\n/* harmony export */ });\n// Frontend to Backend data mapping utilities for NESA signup flow\n// Map frontend account types to backend enum format\nfunction mapAccountType(frontendType) {\n    const mapping = {\n        \"Individual\": \"INDIVIDUAL\",\n        \"NGO\": \"NGO\",\n        \"Corporation\": \"CORPORATION\",\n        \"Government\": \"GOVERNMENT\",\n        \"School\": \"SCHOOL\",\n        \"Diaspora Group\": \"DIASPORA_GROUP\"\n    };\n    return mapping[frontendType] || frontendType;\n}\n// Map frontend intents to backend enum format\nfunction mapIntents(frontendIntents) {\n    const mapping = {\n        \"Vote or Nominate\": \"VOTE_OR_NOMINATE\",\n        \"Apply for Eduaid Scholarship\": \"APPLY_FOR_EDUAID_SCHOLARSHIP\",\n        \"Become Ambassador\": \"BECOME_AMBASSADOR\",\n        \"Join Webinar/Expo\": \"JOIN_WEBINAR_EXPO\",\n        \"Sponsor or CSR Partner\": \"SPONSOR_OR_CSR_PARTNER\",\n        \"Apply as Judge\": \"APPLY_AS_JUDGE\",\n        \"Join Local Chapter\": \"JOIN_LOCAL_CHAPTER\",\n        \"Join NESA Team\": \"JOIN_NESA_TEAM\",\n        \"Get Gala Ticket\": \"GET_GALA_TICKET\",\n        \"Donate\": \"DONATE\",\n        \"Apply as NRC Volunteer\": \"APPLY_AS_NRC_VOLUNTEER\"\n    };\n    return frontendIntents.map((intent)=>mapping[intent] || intent);\n}\n// Map frontend gender to backend enum format\nfunction mapGender(frontendGender) {\n    const mapping = {\n        \"Male\": \"MALE\",\n        \"Female\": \"FEMALE\",\n        \"Other\": \"OTHER\",\n        \"Prefer not to say\": \"PREFER_NOT_TO_SAY\"\n    };\n    return mapping[frontendGender] || frontendGender;\n}\n// Map frontend language to backend enum format\nfunction mapLanguage(frontendLanguage) {\n    // Languages are already in correct format (EN, FR, AR, PT)\n    return frontendLanguage;\n}\n// Main mapping function to convert frontend form data to backend format\nfunction mapFormDataToBackend(frontendData) {\n    const baseData = {\n        email: frontendData.email,\n        password: frontendData.password,\n        country: frontendData.country,\n        state: frontendData.state,\n        accountType: mapAccountType(frontendData.accountType),\n        intents: frontendData.intents ? mapIntents(frontendData.intents) : undefined,\n        preferredLanguage: frontendData.preferredLanguage ? mapLanguage(frontendData.preferredLanguage) : \"EN\"\n    };\n    // Add account-type specific fields\n    if (frontendData.accountType === \"Individual\") {\n        return {\n            ...baseData,\n            fullName: frontendData.fullName,\n            phoneNumber: frontendData.phoneNumber,\n            gender: frontendData.gender ? mapGender(frontendData.gender) : undefined,\n            dateOfBirth: frontendData.dateOfBirth\n        };\n    } else {\n        // Organization data\n        return {\n            ...baseData,\n            organizationName: frontendData.organizationName,\n            registrationNumber: frontendData.registrationNumber,\n            contactPersonName: frontendData.contactPersonName,\n            contactEmail: frontendData.contactEmail,\n            contactPhone: frontendData.contactPhone,\n            organizationType: frontendData.organizationType\n        };\n    }\n}\n// Map backend response to frontend format\nfunction mapBackendResponseToFrontend(backendResponse) {\n    var _backendResponse_data, _backendResponse_data1;\n    return {\n        success: backendResponse.success,\n        message: backendResponse.message,\n        user: ((_backendResponse_data = backendResponse.data) === null || _backendResponse_data === void 0 ? void 0 : _backendResponse_data.user) ? {\n            id: backendResponse.data.user.id,\n            email: backendResponse.data.user.email,\n            role: backendResponse.data.user.role,\n            accountType: backendResponse.data.user.accountType,\n            isVerified: backendResponse.data.user.isVerified,\n            fullName: backendResponse.data.user.fullName,\n            firstName: backendResponse.data.user.firstName,\n            lastName: backendResponse.data.user.lastName\n        } : undefined,\n        tokens: (_backendResponse_data1 = backendResponse.data) === null || _backendResponse_data1 === void 0 ? void 0 : _backendResponse_data1.tokens\n    };\n}\n// Determine expected dashboard route based on role and intents\nfunction getDashboardRoute(role, intents) {\n    // Map backend roles to frontend dashboard routes\n    switch(role){\n        case \"AMBASSADOR\":\n            return \"/ambassador/dashboard\";\n        case \"JUDGE\":\n            return \"/judge/dashboard\";\n        case \"NRC_VOLUNTEER\":\n            return \"/get-involved/nrc-volunteer/dashboard\";\n        case \"SPONSOR\":\n            return \"/sponsor/dashboard\";\n        case \"VOLUNTEER\":\n            return \"/volunteer/dashboard\";\n        case \"ADMIN\":\n        case \"SUPER_ADMIN\":\n            return \"/admin/dashboard\";\n        case \"CHAPTER_LEADER\":\n            return \"/chapter/dashboard\";\n        default:\n            return \"/member/dashboard\";\n    }\n}\n// Determine if an intent requires an application process\nfunction requiresApplication(intent) {\n    const applicationRequiredIntents = [\n        \"Apply as Judge\",\n        \"Apply as NRC Volunteer\",\n        \"Become Ambassador\",\n        \"Join NESA Team\" // May require application for certain positions\n    ];\n    return applicationRequiredIntents.includes(intent);\n}\n// Get application type for an intent\nfunction getApplicationType(intent) {\n    const intentToApplicationType = {\n        \"Apply as Judge\": \"JUDGE\",\n        \"Apply as NRC Volunteer\": \"NRC_VOLUNTEER\",\n        \"Become Ambassador\": \"AMBASSADOR\",\n        \"Join NESA Team\": \"VOLUNTEER\"\n    };\n    return intentToApplicationType[intent] || null;\n}\n// Determine post-signup actions based on user intents\nfunction getPostSignupActions(intents) {\n    const actions = [];\n    for (const intent of intents){\n        if (requiresApplication(intent)) {\n            const applicationType = getApplicationType(intent);\n            if (applicationType) {\n                actions.push({\n                    type: \"application\",\n                    action: \"start_application\",\n                    data: {\n                        applicationType,\n                        intent,\n                        message: \"Complete your \".concat(intent.toLowerCase(), \" application to get started.\")\n                    }\n                });\n            }\n        } else {\n            // Direct access intents\n            switch(intent){\n                case \"Vote or Nominate\":\n                    actions.push({\n                        type: \"redirect\",\n                        action: \"/vote\",\n                        data: {\n                            message: \"You can now vote and nominate candidates!\"\n                        }\n                    });\n                    break;\n                case \"Sponsor or CSR Partner\":\n                    actions.push({\n                        type: \"redirect\",\n                        action: \"/sponsor/packages\",\n                        data: {\n                            message: \"Explore our sponsorship packages.\"\n                        }\n                    });\n                    break;\n                case \"Join Local Chapter\":\n                    actions.push({\n                        type: \"redirect\",\n                        action: \"/chapters\",\n                        data: {\n                            message: \"Find and join your local NESA chapter.\"\n                        }\n                    });\n                    break;\n                default:\n                    actions.push({\n                        type: \"notification\",\n                        action: \"welcome\",\n                        data: {\n                            message: \"Welcome! You can now access \".concat(intent.toLowerCase(), \" features.\")\n                        }\n                    });\n            }\n        }\n    }\n    return actions;\n}\n// Validate that frontend data meets backend requirements\nfunction validateBackendRequirements(frontendData) {\n    const errors = [];\n    // Required fields for all account types\n    if (!frontendData.email) errors.push(\"Email is required\");\n    if (!frontendData.password) errors.push(\"Password is required\");\n    if (!frontendData.country) errors.push(\"Country is required\");\n    if (!frontendData.state) errors.push(\"State is required\");\n    if (!frontendData.accountType) errors.push(\"Account type is required\");\n    // Individual-specific requirements\n    if (frontendData.accountType === \"Individual\") {\n        if (!frontendData.fullName) errors.push(\"Full name is required for individual accounts\");\n    }\n    // Organization-specific requirements\n    if (frontendData.accountType !== \"Individual\") {\n        if (!frontendData.organizationName) errors.push(\"Organization name is required\");\n        if (!frontendData.contactPersonName) errors.push(\"Contact person name is required\");\n        if (!frontendData.contactEmail) errors.push(\"Contact email is required\");\n    }\n    return errors;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi91dGlscy9zaWdudXBNYXBwaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBSWxFLG9EQUFvRDtBQUM3QyxTQUFTQSxlQUFlQyxZQUFvQjtJQUNqRCxNQUFNQyxVQUFrQztRQUN0QyxjQUFjO1FBQ2QsT0FBTztRQUNQLGVBQWU7UUFDZixjQUFjO1FBQ2QsVUFBVTtRQUNWLGtCQUFrQjtJQUNwQjtJQUNBLE9BQU9BLE9BQU8sQ0FBQ0QsYUFBYSxJQUFJQTtBQUNsQztBQUVBLDhDQUE4QztBQUN2QyxTQUFTRSxXQUFXQyxlQUF5QjtJQUNsRCxNQUFNRixVQUFrQztRQUN0QyxvQkFBb0I7UUFDcEIsZ0NBQWdDO1FBQ2hDLHFCQUFxQjtRQUNyQixxQkFBcUI7UUFDckIsMEJBQTBCO1FBQzFCLGtCQUFrQjtRQUNsQixzQkFBc0I7UUFDdEIsa0JBQWtCO1FBQ2xCLG1CQUFtQjtRQUNuQixVQUFVO1FBQ1YsMEJBQTBCO0lBQzVCO0lBRUEsT0FBT0UsZ0JBQWdCQyxHQUFHLENBQUNDLENBQUFBLFNBQVVKLE9BQU8sQ0FBQ0ksT0FBTyxJQUFJQTtBQUMxRDtBQUVBLDZDQUE2QztBQUN0QyxTQUFTQyxVQUFVQyxjQUFzQjtJQUM5QyxNQUFNTixVQUFrQztRQUN0QyxRQUFRO1FBQ1IsVUFBVTtRQUNWLFNBQVM7UUFDVCxxQkFBcUI7SUFDdkI7SUFDQSxPQUFPQSxPQUFPLENBQUNNLGVBQWUsSUFBSUE7QUFDcEM7QUFFQSwrQ0FBK0M7QUFDeEMsU0FBU0MsWUFBWUMsZ0JBQXdCO0lBQ2xELDJEQUEyRDtJQUMzRCxPQUFPQTtBQUNUO0FBRUEsd0VBQXdFO0FBQ2pFLFNBQVNDLHFCQUFxQkMsWUFBNEI7SUFDL0QsTUFBTUMsV0FBVztRQUNmQyxPQUFPRixhQUFhRSxLQUFLO1FBQ3pCQyxVQUFVSCxhQUFhRyxRQUFRO1FBQy9CQyxTQUFTSixhQUFhSSxPQUFPO1FBQzdCQyxPQUFPTCxhQUFhSyxLQUFLO1FBQ3pCQyxhQUFhbEIsZUFBZVksYUFBYU0sV0FBVztRQUNwREMsU0FBU1AsYUFBYU8sT0FBTyxHQUFHaEIsV0FBV1MsYUFBYU8sT0FBTyxJQUFJQztRQUNuRUMsbUJBQW1CVCxhQUFhUyxpQkFBaUIsR0FBR1osWUFBWUcsYUFBYVMsaUJBQWlCLElBQUk7SUFDcEc7SUFFQSxtQ0FBbUM7SUFDbkMsSUFBSVQsYUFBYU0sV0FBVyxLQUFLLGNBQWM7UUFDN0MsT0FBTztZQUNMLEdBQUdMLFFBQVE7WUFDWFMsVUFBVVYsYUFBYVUsUUFBUTtZQUMvQkMsYUFBYVgsYUFBYVcsV0FBVztZQUNyQ0MsUUFBUVosYUFBYVksTUFBTSxHQUFHakIsVUFBVUssYUFBYVksTUFBTSxJQUFJSjtZQUMvREssYUFBYWIsYUFBYWEsV0FBVztRQUN2QztJQUNGLE9BQU87UUFDTCxvQkFBb0I7UUFDcEIsT0FBTztZQUNMLEdBQUdaLFFBQVE7WUFDWGEsa0JBQWtCZCxhQUFhYyxnQkFBZ0I7WUFDL0NDLG9CQUFvQmYsYUFBYWUsa0JBQWtCO1lBQ25EQyxtQkFBbUJoQixhQUFhZ0IsaUJBQWlCO1lBQ2pEQyxjQUFjakIsYUFBYWlCLFlBQVk7WUFDdkNDLGNBQWNsQixhQUFha0IsWUFBWTtZQUN2Q0Msa0JBQWtCbkIsYUFBYW1CLGdCQUFnQjtRQUNqRDtJQUNGO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDbkMsU0FBU0MsNkJBQTZCQyxlQUFvQjtRQUl2REEsdUJBVUVBO0lBYlYsT0FBTztRQUNMQyxTQUFTRCxnQkFBZ0JDLE9BQU87UUFDaENDLFNBQVNGLGdCQUFnQkUsT0FBTztRQUNoQ0MsTUFBTUgsRUFBQUEsd0JBQUFBLGdCQUFnQkksSUFBSSxjQUFwQkosNENBQUFBLHNCQUFzQkcsSUFBSSxJQUFHO1lBQ2pDRSxJQUFJTCxnQkFBZ0JJLElBQUksQ0FBQ0QsSUFBSSxDQUFDRSxFQUFFO1lBQ2hDeEIsT0FBT21CLGdCQUFnQkksSUFBSSxDQUFDRCxJQUFJLENBQUN0QixLQUFLO1lBQ3RDeUIsTUFBTU4sZ0JBQWdCSSxJQUFJLENBQUNELElBQUksQ0FBQ0csSUFBSTtZQUNwQ3JCLGFBQWFlLGdCQUFnQkksSUFBSSxDQUFDRCxJQUFJLENBQUNsQixXQUFXO1lBQ2xEc0IsWUFBWVAsZ0JBQWdCSSxJQUFJLENBQUNELElBQUksQ0FBQ0ksVUFBVTtZQUNoRGxCLFVBQVVXLGdCQUFnQkksSUFBSSxDQUFDRCxJQUFJLENBQUNkLFFBQVE7WUFDNUNtQixXQUFXUixnQkFBZ0JJLElBQUksQ0FBQ0QsSUFBSSxDQUFDSyxTQUFTO1lBQzlDQyxVQUFVVCxnQkFBZ0JJLElBQUksQ0FBQ0QsSUFBSSxDQUFDTSxRQUFRO1FBQzlDLElBQUl0QjtRQUNKdUIsTUFBTSxHQUFFVix5QkFBQUEsZ0JBQWdCSSxJQUFJLGNBQXBCSiw2Q0FBQUEsdUJBQXNCVSxNQUFNO0lBQ3RDO0FBQ0Y7QUFFQSwrREFBK0Q7QUFDeEQsU0FBU0Msa0JBQWtCTCxJQUFZLEVBQUVwQixPQUFrQjtJQUNoRSxpREFBaUQ7SUFDakQsT0FBUW9CO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPO0lBQ1g7QUFDRjtBQUVBLHlEQUF5RDtBQUNsRCxTQUFTTSxvQkFBb0J2QyxNQUFjO0lBQ2hELE1BQU13Qyw2QkFBNkI7UUFDakM7UUFDQTtRQUNBO1FBQ0EsaUJBQWlCLGdEQUFnRDtLQUNsRTtJQUVELE9BQU9BLDJCQUEyQkMsUUFBUSxDQUFDekM7QUFDN0M7QUFFQSxxQ0FBcUM7QUFDOUIsU0FBUzBDLG1CQUFtQjFDLE1BQWM7SUFDL0MsTUFBTTJDLDBCQUFrRDtRQUN0RCxrQkFBa0I7UUFDbEIsMEJBQTBCO1FBQzFCLHFCQUFxQjtRQUNyQixrQkFBa0I7SUFDcEI7SUFFQSxPQUFPQSx1QkFBdUIsQ0FBQzNDLE9BQU8sSUFBSTtBQUM1QztBQUVBLHNEQUFzRDtBQUMvQyxTQUFTNEMscUJBQXFCL0IsT0FBaUI7SUFLcEQsTUFBTWdDLFVBSUQsRUFBRTtJQUVQLEtBQUssTUFBTTdDLFVBQVVhLFFBQVM7UUFDNUIsSUFBSTBCLG9CQUFvQnZDLFNBQVM7WUFDL0IsTUFBTThDLGtCQUFrQkosbUJBQW1CMUM7WUFDM0MsSUFBSThDLGlCQUFpQjtnQkFDbkJELFFBQVFFLElBQUksQ0FBQztvQkFDWEMsTUFBTTtvQkFDTkMsUUFBUTtvQkFDUmxCLE1BQU07d0JBQ0plO3dCQUNBOUM7d0JBQ0E2QixTQUFTLGlCQUFzQyxPQUFyQjdCLE9BQU9rRCxXQUFXLElBQUc7b0JBQ2pEO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsd0JBQXdCO1lBQ3hCLE9BQVFsRDtnQkFDTixLQUFLO29CQUNINkMsUUFBUUUsSUFBSSxDQUFDO3dCQUNYQyxNQUFNO3dCQUNOQyxRQUFRO3dCQUNSbEIsTUFBTTs0QkFBRUYsU0FBUzt3QkFBNEM7b0JBQy9EO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0hnQixRQUFRRSxJQUFJLENBQUM7d0JBQ1hDLE1BQU07d0JBQ05DLFFBQVE7d0JBQ1JsQixNQUFNOzRCQUFFRixTQUFTO3dCQUFvQztvQkFDdkQ7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSGdCLFFBQVFFLElBQUksQ0FBQzt3QkFDWEMsTUFBTTt3QkFDTkMsUUFBUTt3QkFDUmxCLE1BQU07NEJBQUVGLFNBQVM7d0JBQXlDO29CQUM1RDtvQkFDQTtnQkFDRjtvQkFDRWdCLFFBQVFFLElBQUksQ0FBQzt3QkFDWEMsTUFBTTt3QkFDTkMsUUFBUTt3QkFDUmxCLE1BQU07NEJBQUVGLFNBQVMsK0JBQW9ELE9BQXJCN0IsT0FBT2tELFdBQVcsSUFBRzt3QkFBWTtvQkFDbkY7WUFDSjtRQUNGO0lBQ0Y7SUFFQSxPQUFPTDtBQUNUO0FBRUEseURBQXlEO0FBQ2xELFNBQVNNLDRCQUE0QjdDLFlBQTRCO0lBQ3RFLE1BQU04QyxTQUFtQixFQUFFO0lBRTNCLHdDQUF3QztJQUN4QyxJQUFJLENBQUM5QyxhQUFhRSxLQUFLLEVBQUU0QyxPQUFPTCxJQUFJLENBQUM7SUFDckMsSUFBSSxDQUFDekMsYUFBYUcsUUFBUSxFQUFFMkMsT0FBT0wsSUFBSSxDQUFDO0lBQ3hDLElBQUksQ0FBQ3pDLGFBQWFJLE9BQU8sRUFBRTBDLE9BQU9MLElBQUksQ0FBQztJQUN2QyxJQUFJLENBQUN6QyxhQUFhSyxLQUFLLEVBQUV5QyxPQUFPTCxJQUFJLENBQUM7SUFDckMsSUFBSSxDQUFDekMsYUFBYU0sV0FBVyxFQUFFd0MsT0FBT0wsSUFBSSxDQUFDO0lBRTNDLG1DQUFtQztJQUNuQyxJQUFJekMsYUFBYU0sV0FBVyxLQUFLLGNBQWM7UUFDN0MsSUFBSSxDQUFDTixhQUFhVSxRQUFRLEVBQUVvQyxPQUFPTCxJQUFJLENBQUM7SUFDMUM7SUFFQSxxQ0FBcUM7SUFDckMsSUFBSXpDLGFBQWFNLFdBQVcsS0FBSyxjQUFjO1FBQzdDLElBQUksQ0FBQ04sYUFBYWMsZ0JBQWdCLEVBQUVnQyxPQUFPTCxJQUFJLENBQUM7UUFDaEQsSUFBSSxDQUFDekMsYUFBYWdCLGlCQUFpQixFQUFFOEIsT0FBT0wsSUFBSSxDQUFDO1FBQ2pELElBQUksQ0FBQ3pDLGFBQWFpQixZQUFZLEVBQUU2QixPQUFPTCxJQUFJLENBQUM7SUFDOUM7SUFFQSxPQUFPSztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi91dGlscy9zaWdudXBNYXBwaW5nLnRzP2Y0ODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnJvbnRlbmQgdG8gQmFja2VuZCBkYXRhIG1hcHBpbmcgdXRpbGl0aWVzIGZvciBORVNBIHNpZ251cCBmbG93XG5cbmltcG9ydCB7IFNpZ251cEZvcm1EYXRhIH0gZnJvbSAnQC9saWIvdHlwZXMvc2lnbnVwJztcblxuLy8gTWFwIGZyb250ZW5kIGFjY291bnQgdHlwZXMgdG8gYmFja2VuZCBlbnVtIGZvcm1hdFxuZXhwb3J0IGZ1bmN0aW9uIG1hcEFjY291bnRUeXBlKGZyb250ZW5kVHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnSW5kaXZpZHVhbCc6ICdJTkRJVklEVUFMJyxcbiAgICAnTkdPJzogJ05HTycsXG4gICAgJ0NvcnBvcmF0aW9uJzogJ0NPUlBPUkFUSU9OJyxcbiAgICAnR292ZXJubWVudCc6ICdHT1ZFUk5NRU5UJyxcbiAgICAnU2Nob29sJzogJ1NDSE9PTCcsXG4gICAgJ0RpYXNwb3JhIEdyb3VwJzogJ0RJQVNQT1JBX0dST1VQJ1xuICB9O1xuICByZXR1cm4gbWFwcGluZ1tmcm9udGVuZFR5cGVdIHx8IGZyb250ZW5kVHlwZTtcbn1cblxuLy8gTWFwIGZyb250ZW5kIGludGVudHMgdG8gYmFja2VuZCBlbnVtIGZvcm1hdFxuZXhwb3J0IGZ1bmN0aW9uIG1hcEludGVudHMoZnJvbnRlbmRJbnRlbnRzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgbWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnVm90ZSBvciBOb21pbmF0ZSc6ICdWT1RFX09SX05PTUlOQVRFJyxcbiAgICAnQXBwbHkgZm9yIEVkdWFpZCBTY2hvbGFyc2hpcCc6ICdBUFBMWV9GT1JfRURVQUlEX1NDSE9MQVJTSElQJyxcbiAgICAnQmVjb21lIEFtYmFzc2Fkb3InOiAnQkVDT01FX0FNQkFTU0FET1InLFxuICAgICdKb2luIFdlYmluYXIvRXhwbyc6ICdKT0lOX1dFQklOQVJfRVhQTycsXG4gICAgJ1Nwb25zb3Igb3IgQ1NSIFBhcnRuZXInOiAnU1BPTlNPUl9PUl9DU1JfUEFSVE5FUicsXG4gICAgJ0FwcGx5IGFzIEp1ZGdlJzogJ0FQUExZX0FTX0pVREdFJyxcbiAgICAnSm9pbiBMb2NhbCBDaGFwdGVyJzogJ0pPSU5fTE9DQUxfQ0hBUFRFUicsXG4gICAgJ0pvaW4gTkVTQSBUZWFtJzogJ0pPSU5fTkVTQV9URUFNJyxcbiAgICAnR2V0IEdhbGEgVGlja2V0JzogJ0dFVF9HQUxBX1RJQ0tFVCcsXG4gICAgJ0RvbmF0ZSc6ICdET05BVEUnLFxuICAgICdBcHBseSBhcyBOUkMgVm9sdW50ZWVyJzogJ0FQUExZX0FTX05SQ19WT0xVTlRFRVInXG4gIH07XG4gIFxuICByZXR1cm4gZnJvbnRlbmRJbnRlbnRzLm1hcChpbnRlbnQgPT4gbWFwcGluZ1tpbnRlbnRdIHx8IGludGVudCk7XG59XG5cbi8vIE1hcCBmcm9udGVuZCBnZW5kZXIgdG8gYmFja2VuZCBlbnVtIGZvcm1hdFxuZXhwb3J0IGZ1bmN0aW9uIG1hcEdlbmRlcihmcm9udGVuZEdlbmRlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnTWFsZSc6ICdNQUxFJyxcbiAgICAnRmVtYWxlJzogJ0ZFTUFMRScsXG4gICAgJ090aGVyJzogJ09USEVSJyxcbiAgICAnUHJlZmVyIG5vdCB0byBzYXknOiAnUFJFRkVSX05PVF9UT19TQVknXG4gIH07XG4gIHJldHVybiBtYXBwaW5nW2Zyb250ZW5kR2VuZGVyXSB8fCBmcm9udGVuZEdlbmRlcjtcbn1cblxuLy8gTWFwIGZyb250ZW5kIGxhbmd1YWdlIHRvIGJhY2tlbmQgZW51bSBmb3JtYXRcbmV4cG9ydCBmdW5jdGlvbiBtYXBMYW5ndWFnZShmcm9udGVuZExhbmd1YWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBMYW5ndWFnZXMgYXJlIGFscmVhZHkgaW4gY29ycmVjdCBmb3JtYXQgKEVOLCBGUiwgQVIsIFBUKVxuICByZXR1cm4gZnJvbnRlbmRMYW5ndWFnZTtcbn1cblxuLy8gTWFpbiBtYXBwaW5nIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbnRlbmQgZm9ybSBkYXRhIHRvIGJhY2tlbmQgZm9ybWF0XG5leHBvcnQgZnVuY3Rpb24gbWFwRm9ybURhdGFUb0JhY2tlbmQoZnJvbnRlbmREYXRhOiBTaWdudXBGb3JtRGF0YSk6IGFueSB7XG4gIGNvbnN0IGJhc2VEYXRhID0ge1xuICAgIGVtYWlsOiBmcm9udGVuZERhdGEuZW1haWwsXG4gICAgcGFzc3dvcmQ6IGZyb250ZW5kRGF0YS5wYXNzd29yZCxcbiAgICBjb3VudHJ5OiBmcm9udGVuZERhdGEuY291bnRyeSxcbiAgICBzdGF0ZTogZnJvbnRlbmREYXRhLnN0YXRlLFxuICAgIGFjY291bnRUeXBlOiBtYXBBY2NvdW50VHlwZShmcm9udGVuZERhdGEuYWNjb3VudFR5cGUpLFxuICAgIGludGVudHM6IGZyb250ZW5kRGF0YS5pbnRlbnRzID8gbWFwSW50ZW50cyhmcm9udGVuZERhdGEuaW50ZW50cykgOiB1bmRlZmluZWQsXG4gICAgcHJlZmVycmVkTGFuZ3VhZ2U6IGZyb250ZW5kRGF0YS5wcmVmZXJyZWRMYW5ndWFnZSA/IG1hcExhbmd1YWdlKGZyb250ZW5kRGF0YS5wcmVmZXJyZWRMYW5ndWFnZSkgOiAnRU4nXG4gIH07XG5cbiAgLy8gQWRkIGFjY291bnQtdHlwZSBzcGVjaWZpYyBmaWVsZHNcbiAgaWYgKGZyb250ZW5kRGF0YS5hY2NvdW50VHlwZSA9PT0gJ0luZGl2aWR1YWwnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJhc2VEYXRhLFxuICAgICAgZnVsbE5hbWU6IGZyb250ZW5kRGF0YS5mdWxsTmFtZSxcbiAgICAgIHBob25lTnVtYmVyOiBmcm9udGVuZERhdGEucGhvbmVOdW1iZXIsXG4gICAgICBnZW5kZXI6IGZyb250ZW5kRGF0YS5nZW5kZXIgPyBtYXBHZW5kZXIoZnJvbnRlbmREYXRhLmdlbmRlcikgOiB1bmRlZmluZWQsXG4gICAgICBkYXRlT2ZCaXJ0aDogZnJvbnRlbmREYXRhLmRhdGVPZkJpcnRoXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPcmdhbml6YXRpb24gZGF0YVxuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlRGF0YSxcbiAgICAgIG9yZ2FuaXphdGlvbk5hbWU6IGZyb250ZW5kRGF0YS5vcmdhbml6YXRpb25OYW1lLFxuICAgICAgcmVnaXN0cmF0aW9uTnVtYmVyOiBmcm9udGVuZERhdGEucmVnaXN0cmF0aW9uTnVtYmVyLFxuICAgICAgY29udGFjdFBlcnNvbk5hbWU6IGZyb250ZW5kRGF0YS5jb250YWN0UGVyc29uTmFtZSxcbiAgICAgIGNvbnRhY3RFbWFpbDogZnJvbnRlbmREYXRhLmNvbnRhY3RFbWFpbCxcbiAgICAgIGNvbnRhY3RQaG9uZTogZnJvbnRlbmREYXRhLmNvbnRhY3RQaG9uZSxcbiAgICAgIG9yZ2FuaXphdGlvblR5cGU6IGZyb250ZW5kRGF0YS5vcmdhbml6YXRpb25UeXBlXG4gICAgfTtcbiAgfVxufVxuXG4vLyBNYXAgYmFja2VuZCByZXNwb25zZSB0byBmcm9udGVuZCBmb3JtYXRcbmV4cG9ydCBmdW5jdGlvbiBtYXBCYWNrZW5kUmVzcG9uc2VUb0Zyb250ZW5kKGJhY2tlbmRSZXNwb25zZTogYW55KTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBiYWNrZW5kUmVzcG9uc2Uuc3VjY2VzcyxcbiAgICBtZXNzYWdlOiBiYWNrZW5kUmVzcG9uc2UubWVzc2FnZSxcbiAgICB1c2VyOiBiYWNrZW5kUmVzcG9uc2UuZGF0YT8udXNlciA/IHtcbiAgICAgIGlkOiBiYWNrZW5kUmVzcG9uc2UuZGF0YS51c2VyLmlkLFxuICAgICAgZW1haWw6IGJhY2tlbmRSZXNwb25zZS5kYXRhLnVzZXIuZW1haWwsXG4gICAgICByb2xlOiBiYWNrZW5kUmVzcG9uc2UuZGF0YS51c2VyLnJvbGUsXG4gICAgICBhY2NvdW50VHlwZTogYmFja2VuZFJlc3BvbnNlLmRhdGEudXNlci5hY2NvdW50VHlwZSxcbiAgICAgIGlzVmVyaWZpZWQ6IGJhY2tlbmRSZXNwb25zZS5kYXRhLnVzZXIuaXNWZXJpZmllZCxcbiAgICAgIGZ1bGxOYW1lOiBiYWNrZW5kUmVzcG9uc2UuZGF0YS51c2VyLmZ1bGxOYW1lLFxuICAgICAgZmlyc3ROYW1lOiBiYWNrZW5kUmVzcG9uc2UuZGF0YS51c2VyLmZpcnN0TmFtZSxcbiAgICAgIGxhc3ROYW1lOiBiYWNrZW5kUmVzcG9uc2UuZGF0YS51c2VyLmxhc3ROYW1lXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICB0b2tlbnM6IGJhY2tlbmRSZXNwb25zZS5kYXRhPy50b2tlbnNcbiAgfTtcbn1cblxuLy8gRGV0ZXJtaW5lIGV4cGVjdGVkIGRhc2hib2FyZCByb3V0ZSBiYXNlZCBvbiByb2xlIGFuZCBpbnRlbnRzXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGFzaGJvYXJkUm91dGUocm9sZTogc3RyaW5nLCBpbnRlbnRzPzogc3RyaW5nW10pOiBzdHJpbmcge1xuICAvLyBNYXAgYmFja2VuZCByb2xlcyB0byBmcm9udGVuZCBkYXNoYm9hcmQgcm91dGVzXG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgJ0FNQkFTU0FET1InOlxuICAgICAgcmV0dXJuICcvYW1iYXNzYWRvci9kYXNoYm9hcmQnO1xuICAgIGNhc2UgJ0pVREdFJzpcbiAgICAgIHJldHVybiAnL2p1ZGdlL2Rhc2hib2FyZCc7XG4gICAgY2FzZSAnTlJDX1ZPTFVOVEVFUic6XG4gICAgICByZXR1cm4gJy9nZXQtaW52b2x2ZWQvbnJjLXZvbHVudGVlci9kYXNoYm9hcmQnO1xuICAgIGNhc2UgJ1NQT05TT1InOlxuICAgICAgcmV0dXJuICcvc3BvbnNvci9kYXNoYm9hcmQnO1xuICAgIGNhc2UgJ1ZPTFVOVEVFUic6XG4gICAgICByZXR1cm4gJy92b2x1bnRlZXIvZGFzaGJvYXJkJztcbiAgICBjYXNlICdBRE1JTic6XG4gICAgY2FzZSAnU1VQRVJfQURNSU4nOlxuICAgICAgcmV0dXJuICcvYWRtaW4vZGFzaGJvYXJkJztcbiAgICBjYXNlICdDSEFQVEVSX0xFQURFUic6XG4gICAgICByZXR1cm4gJy9jaGFwdGVyL2Rhc2hib2FyZCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnL21lbWJlci9kYXNoYm9hcmQnO1xuICB9XG59XG5cbi8vIERldGVybWluZSBpZiBhbiBpbnRlbnQgcmVxdWlyZXMgYW4gYXBwbGljYXRpb24gcHJvY2Vzc1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVzQXBwbGljYXRpb24oaW50ZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYXBwbGljYXRpb25SZXF1aXJlZEludGVudHMgPSBbXG4gICAgJ0FwcGx5IGFzIEp1ZGdlJyxcbiAgICAnQXBwbHkgYXMgTlJDIFZvbHVudGVlcicsXG4gICAgJ0JlY29tZSBBbWJhc3NhZG9yJywgLy8gTWF5IHJlcXVpcmUgYXBwbGljYXRpb24gaW4gc29tZSBjYXNlc1xuICAgICdKb2luIE5FU0EgVGVhbScgLy8gTWF5IHJlcXVpcmUgYXBwbGljYXRpb24gZm9yIGNlcnRhaW4gcG9zaXRpb25zXG4gIF07XG5cbiAgcmV0dXJuIGFwcGxpY2F0aW9uUmVxdWlyZWRJbnRlbnRzLmluY2x1ZGVzKGludGVudCk7XG59XG5cbi8vIEdldCBhcHBsaWNhdGlvbiB0eXBlIGZvciBhbiBpbnRlbnRcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcHBsaWNhdGlvblR5cGUoaW50ZW50OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgaW50ZW50VG9BcHBsaWNhdGlvblR5cGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ0FwcGx5IGFzIEp1ZGdlJzogJ0pVREdFJyxcbiAgICAnQXBwbHkgYXMgTlJDIFZvbHVudGVlcic6ICdOUkNfVk9MVU5URUVSJyxcbiAgICAnQmVjb21lIEFtYmFzc2Fkb3InOiAnQU1CQVNTQURPUicsXG4gICAgJ0pvaW4gTkVTQSBUZWFtJzogJ1ZPTFVOVEVFUidcbiAgfTtcblxuICByZXR1cm4gaW50ZW50VG9BcHBsaWNhdGlvblR5cGVbaW50ZW50XSB8fCBudWxsO1xufVxuXG4vLyBEZXRlcm1pbmUgcG9zdC1zaWdudXAgYWN0aW9ucyBiYXNlZCBvbiB1c2VyIGludGVudHNcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3N0U2lnbnVwQWN0aW9ucyhpbnRlbnRzOiBzdHJpbmdbXSk6IEFycmF5PHtcbiAgdHlwZTogJ2FwcGxpY2F0aW9uJyB8ICdyZWRpcmVjdCcgfCAnbm90aWZpY2F0aW9uJztcbiAgYWN0aW9uOiBzdHJpbmc7XG4gIGRhdGE/OiBhbnk7XG59PiB7XG4gIGNvbnN0IGFjdGlvbnM6IEFycmF5PHtcbiAgICB0eXBlOiAnYXBwbGljYXRpb24nIHwgJ3JlZGlyZWN0JyB8ICdub3RpZmljYXRpb24nO1xuICAgIGFjdGlvbjogc3RyaW5nO1xuICAgIGRhdGE/OiBhbnk7XG4gIH0+ID0gW107XG5cbiAgZm9yIChjb25zdCBpbnRlbnQgb2YgaW50ZW50cykge1xuICAgIGlmIChyZXF1aXJlc0FwcGxpY2F0aW9uKGludGVudCkpIHtcbiAgICAgIGNvbnN0IGFwcGxpY2F0aW9uVHlwZSA9IGdldEFwcGxpY2F0aW9uVHlwZShpbnRlbnQpO1xuICAgICAgaWYgKGFwcGxpY2F0aW9uVHlwZSkge1xuICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgYWN0aW9uOiAnc3RhcnRfYXBwbGljYXRpb24nLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uVHlwZSxcbiAgICAgICAgICAgIGludGVudCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDb21wbGV0ZSB5b3VyICR7aW50ZW50LnRvTG93ZXJDYXNlKCl9IGFwcGxpY2F0aW9uIHRvIGdldCBzdGFydGVkLmBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEaXJlY3QgYWNjZXNzIGludGVudHNcbiAgICAgIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgICAgIGNhc2UgJ1ZvdGUgb3IgTm9taW5hdGUnOlxuICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QnLFxuICAgICAgICAgICAgYWN0aW9uOiAnL3ZvdGUnLFxuICAgICAgICAgICAgZGF0YTogeyBtZXNzYWdlOiAnWW91IGNhbiBub3cgdm90ZSBhbmQgbm9taW5hdGUgY2FuZGlkYXRlcyEnIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU3BvbnNvciBvciBDU1IgUGFydG5lcic6XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICBhY3Rpb246ICcvc3BvbnNvci9wYWNrYWdlcycsXG4gICAgICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6ICdFeHBsb3JlIG91ciBzcG9uc29yc2hpcCBwYWNrYWdlcy4nIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSm9pbiBMb2NhbCBDaGFwdGVyJzpcbiAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgIGFjdGlvbjogJy9jaGFwdGVycycsXG4gICAgICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6ICdGaW5kIGFuZCBqb2luIHlvdXIgbG9jYWwgTkVTQSBjaGFwdGVyLicgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbm90aWZpY2F0aW9uJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ3dlbGNvbWUnLFxuICAgICAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBgV2VsY29tZSEgWW91IGNhbiBub3cgYWNjZXNzICR7aW50ZW50LnRvTG93ZXJDYXNlKCl9IGZlYXR1cmVzLmAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY3Rpb25zO1xufVxuXG4vLyBWYWxpZGF0ZSB0aGF0IGZyb250ZW5kIGRhdGEgbWVldHMgYmFja2VuZCByZXF1aXJlbWVudHNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhY2tlbmRSZXF1aXJlbWVudHMoZnJvbnRlbmREYXRhOiBTaWdudXBGb3JtRGF0YSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIFJlcXVpcmVkIGZpZWxkcyBmb3IgYWxsIGFjY291bnQgdHlwZXNcbiAgaWYgKCFmcm9udGVuZERhdGEuZW1haWwpIGVycm9ycy5wdXNoKCdFbWFpbCBpcyByZXF1aXJlZCcpO1xuICBpZiAoIWZyb250ZW5kRGF0YS5wYXNzd29yZCkgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIGlzIHJlcXVpcmVkJyk7XG4gIGlmICghZnJvbnRlbmREYXRhLmNvdW50cnkpIGVycm9ycy5wdXNoKCdDb3VudHJ5IGlzIHJlcXVpcmVkJyk7XG4gIGlmICghZnJvbnRlbmREYXRhLnN0YXRlKSBlcnJvcnMucHVzaCgnU3RhdGUgaXMgcmVxdWlyZWQnKTtcbiAgaWYgKCFmcm9udGVuZERhdGEuYWNjb3VudFR5cGUpIGVycm9ycy5wdXNoKCdBY2NvdW50IHR5cGUgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBJbmRpdmlkdWFsLXNwZWNpZmljIHJlcXVpcmVtZW50c1xuICBpZiAoZnJvbnRlbmREYXRhLmFjY291bnRUeXBlID09PSAnSW5kaXZpZHVhbCcpIHtcbiAgICBpZiAoIWZyb250ZW5kRGF0YS5mdWxsTmFtZSkgZXJyb3JzLnB1c2goJ0Z1bGwgbmFtZSBpcyByZXF1aXJlZCBmb3IgaW5kaXZpZHVhbCBhY2NvdW50cycpO1xuICB9XG5cbiAgLy8gT3JnYW5pemF0aW9uLXNwZWNpZmljIHJlcXVpcmVtZW50c1xuICBpZiAoZnJvbnRlbmREYXRhLmFjY291bnRUeXBlICE9PSAnSW5kaXZpZHVhbCcpIHtcbiAgICBpZiAoIWZyb250ZW5kRGF0YS5vcmdhbml6YXRpb25OYW1lKSBlcnJvcnMucHVzaCgnT3JnYW5pemF0aW9uIG5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIWZyb250ZW5kRGF0YS5jb250YWN0UGVyc29uTmFtZSkgZXJyb3JzLnB1c2goJ0NvbnRhY3QgcGVyc29uIG5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIWZyb250ZW5kRGF0YS5jb250YWN0RW1haWwpIGVycm9ycy5wdXNoKCdDb250YWN0IGVtYWlsIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuIl0sIm5hbWVzIjpbIm1hcEFjY291bnRUeXBlIiwiZnJvbnRlbmRUeXBlIiwibWFwcGluZyIsIm1hcEludGVudHMiLCJmcm9udGVuZEludGVudHMiLCJtYXAiLCJpbnRlbnQiLCJtYXBHZW5kZXIiLCJmcm9udGVuZEdlbmRlciIsIm1hcExhbmd1YWdlIiwiZnJvbnRlbmRMYW5ndWFnZSIsIm1hcEZvcm1EYXRhVG9CYWNrZW5kIiwiZnJvbnRlbmREYXRhIiwiYmFzZURhdGEiLCJlbWFpbCIsInBhc3N3b3JkIiwiY291bnRyeSIsInN0YXRlIiwiYWNjb3VudFR5cGUiLCJpbnRlbnRzIiwidW5kZWZpbmVkIiwicHJlZmVycmVkTGFuZ3VhZ2UiLCJmdWxsTmFtZSIsInBob25lTnVtYmVyIiwiZ2VuZGVyIiwiZGF0ZU9mQmlydGgiLCJvcmdhbml6YXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTnVtYmVyIiwiY29udGFjdFBlcnNvbk5hbWUiLCJjb250YWN0RW1haWwiLCJjb250YWN0UGhvbmUiLCJvcmdhbml6YXRpb25UeXBlIiwibWFwQmFja2VuZFJlc3BvbnNlVG9Gcm9udGVuZCIsImJhY2tlbmRSZXNwb25zZSIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidXNlciIsImRhdGEiLCJpZCIsInJvbGUiLCJpc1ZlcmlmaWVkIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJ0b2tlbnMiLCJnZXREYXNoYm9hcmRSb3V0ZSIsInJlcXVpcmVzQXBwbGljYXRpb24iLCJhcHBsaWNhdGlvblJlcXVpcmVkSW50ZW50cyIsImluY2x1ZGVzIiwiZ2V0QXBwbGljYXRpb25UeXBlIiwiaW50ZW50VG9BcHBsaWNhdGlvblR5cGUiLCJnZXRQb3N0U2lnbnVwQWN0aW9ucyIsImFjdGlvbnMiLCJhcHBsaWNhdGlvblR5cGUiLCJwdXNoIiwidHlwZSIsImFjdGlvbiIsInRvTG93ZXJDYXNlIiwidmFsaWRhdGVCYWNrZW5kUmVxdWlyZW1lbnRzIiwiZXJyb3JzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils/signupMapping.ts\n"));

/***/ })

}]);